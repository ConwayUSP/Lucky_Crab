# Tipos e Vari√°veis

Agora que sabemos como criar e rodar nossos projetos **vamos come√ßar** a aprender Rust pravaler!

## Declarando uma vari√°vel

Em toda linguagem de programa√ß√£o temos vari√°veis, nosso pequenos armaz√©ns de informa√ß√£o. Para declarar uma vari√°vel no Rust usando a palavra reservada `let`.

~~~rust

fn main() {
    let x = 10;
    println!("x = {}", x);
}

~~~


Nesse c√≥digo criamos uma vari√°vel do tipo inteiro, e printamos ela na tela. O resultado esperado ser√° `x = 10`

> Fazendo uma anedota, a fun√ß√£o(/macro) `println!`, tem como primeiro parametro uma string literal de texto, por√©m ela tamb√©m aceita um n√∫mero vari√°vel de argumentos que v√£o ser formatados dentro do texto, e para inserir esses outros argumentos usamos duas chaves `{}`.

> E para voc√™ que est√° acostumado com C/C++, Rust consegue inferir tipos na maioria dos casos quando usando `let`. Equivalente ao `var` em Java.

## Vari√°veis Mut√°veis

Existe um pequeno detalhe n√£o falado anteriormente, `let` cria **vari√°veis imut√°veis**. Quer dizer que seu c√≥digo **n√£o vai compilar** se fizermos isso:

```rust

let x = 10;

x = 15;

```

Para criar vari√°veis que podemos alterar durante o programa, devemos adicionar a palavra chave `mut`.

```rust
let mut x = 10;
println!("x = {}", x);

x = 11;
println!("x = {}", x);
```
Agora sim, nosso c√≥digo compila e executa como queremos!

> O porqu√™ disso: Rust gosta de ser bem claro e espec√≠fico, quanto a inten√ß√£o do programador, se voc√™ quer que algo seja mut√°vel, voc√™ __deve__ especificar, assim ajudando quem est√° lendo seu c√≥digo, e ajudando voc√™ a previr _bugs_ acidentais, como alterar uma vari√°vel que n√£o deveria.

## Tipos Primitivos

Se voc√™ est√° acostumado com programa√ß√£o, j√° sabe o que s√£o tipos primitivos, entre eles temos, n√∫meros inteiros, reais, strings e outros, vamos explora-los em Rust.

### Declara√ß√£o Expl√≠cita de tipos

Rust pode na maior parte das vezes inferir os tipos das vari√°veis, por√©m para tipos ou opera√ß√µes mais complexas n√£o, ou a vezes queremos deixar bem claro o tipo de uma vari√°vel, ent√£o podemos declarar explicitamente o tipo da vari√°vel.

```rust

let x: u32 = 18;
```

Vamos agora aprender sobre cada tipo.

### Tipo Inteiro

Para os inteiros Rust tem v√°rios tipos dependendo do quanto de mem√≥ria voc√™ quer utilizar. A linguagem difere inteiros entre _tamanho_ e _sinal_ (_unsigned_/_signed_), um tipo _signed_ pode ter valores negativos, enquanto um tipo _unsigned_ s√≥ pode ter valores de zero e positivos. Segue a lista de tipos:

| Tamanho | Signed | Unsigned |
| --- | --- | --- | 
| 8-bit | i8 | u8 |
| 16-bit | i16 | u16 |
| 32-bit | i32 | u32 |
| 64-bit | i64 | u64 |
| 128-bit | i128 | u128 |
| arch* | isize | usize |

> arch: refere-se a arquitetura do computador, x32 equivale a 32-bit, e x64 √† 64-bit.

O intervalo de n√∫meros para cada tipo segue a seguinte f√≥rmula: de 0 a 2^n para _unsigned_, e -2^n a 2^n - 1 para _signed_.

### Tipo Float

N√∫meros reais temos 2 tipos, `f32` para floats de 32-bit e `f64` para floats de 64-bit. Equivalem aos tipos `float` e `double` em C, Java, etc.

### Tipo Booleano

Diferente do C, temos um tipo espec√≠fico para representar os estados VERDADEIRO e FALSO. No Rust, chamamos esse tipo de `bool`, que assume somente dois valores, `true` e `false`.


### Tipo Charact√©r

Representa um caract√©r _UTF-8_ usando aspa √∫nica, diferente de aspas duplas que representam _strings_.

```rust
let c = 'z';

let emoji: char = 'ü¶Ä';
```

Nem tudo que voc√™ **acha** que √© um caract√©r, realmente **√©** um caract√©r. Para aprender mais sobre o formato _UTF-8_ veja essa p√°gina [UTF-8 Wikipedia](https://pt.wikipedia.org/wiki/UTF-8)

### Tipo Array

Assim como a linguagem C, Rust tem um tipo array, neste caso, um array √© uma sequ√™ncia de tamanho _fixo_, e de tipo _homog√™neo_ (todo os valores tem o mesmo tipo).

```rust 

fn main() {
    let a: [u32; 5] = [1, 2, 3, 4, 5]; // Declara√ß√£o explicita do tipo √© opcional
    
    println!("= {}", a[0]); // O acesso ao array √© id√™ntico ao C
    // = 0
}

```

Acessar valores fora do array causa um _panic_, em outras palavras o programa encerra abrubtamente, para impedir acesso inv√°lido ou n√£o autorizado de mem√≥ria. Vamos explorar o _panic_ em outra se√ß√£o desde tutorial.


> Nota: em Rust arrays **n√£o** decaem para ponteiros, se voc√™ n√£o programa em C, ignore essa mensagem.

### Tipo T√∫pla

T√∫pla √© um tipo usado para agrupar tipos juntos, atrav√©s de uma lista de tipos. Valores podem ser acessado por `.` ou a t√∫pla em si pode ser desestruturada em vari√°veis, o que √© √∫til para fun√ß√µes que retornam v√°rios valores.

```rust
fn main() {
    let tup: (i32, f64, bool) = (600, 3.2, false);

    println!("{}", tup.0); // 600

    let (x, y, z) = tup; 

    println!("{}", y); // 3.2
}
```


#### Tipo _Unit_ `()`

Como vimos antes a fun√ß√£o _main_ retorna um tipo _unit_ que √© nada mais nada menos que uma t√∫pla vazia, indicando que o valor retornado tem tamanho _zero_. Ou seja, na pr√°tica nada √© retornado.

## Ap√™ndice: Constantes

Constantes no Rust s√£o parecidas com vari√°veis imut√°veis, por√©m com certas diferen√ßas. Elas podem ser declaradas no _escopo global_ (fora da fun√ß√£o _main_), e tem o poder de serem resolvidas em tempo de compila√ß√£o, parecido com macros em C e `constexpr` no C++. Em outras palavras se voc√™ quiser deixar um valor pr√©-calculado voc√™ pode usar uma constante.

Elas devem ser declaradas da seguinte forma `const NOME: tipo = express√£o`. Conforme exemplo.
```
const ONE_HOUR_IN_SECONDS: u32 = 60 * 60;
```

Assim, quando usarmos essa constante o valor `3600` vai ser utilizado pelo programa.

> Importante notar que nem tudo pode ser executado em tempo de compila√ß√£o. Coisas como opera√ß√µes artim√©ticas podem, mas outras como alocar mem√≥ria din√¢mica n√£o.
