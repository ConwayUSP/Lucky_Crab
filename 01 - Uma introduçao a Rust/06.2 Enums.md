# 6.1 Enums

Vamos falar agora de _enums_ ou enumerações, eles servem para dizer que dentro de um tipo, existe uma certo número de valores possíveis. Por exemplo, tipos de endereços de IP, que podem ter 2 versões, V4 e V6. Podemos representá-los da seguinte forma.

```rust

enum IpAddress {
    V4,
    V6
}

// exemplo de uso
fn route(ip: IpAddress) {}

fn main() {
    route(IpAddress::V4);
}
```

Além disso, é possível inserir dados dentro de cada variância de enums. Usando o exemplo de endereços de IP.

```rust

enum IpAddress {
    V4(String),
    V6(String),
}

fn main() {
    // A variável carrega a variância V4 e possui nossa String
    let home = IpAddress::V4(String::from("127.0.0.1"));
}

```

Podemos usar também diferentes tipos de dados.

```rust

enum IpAddress {
    V4(u8, u8, u8, u8), // Declaramos como uma tupla
    V6(String),
}

fn main() {
    // A variável carrega a variância V4 e possui nossa String
    let home = IpAddress::V4(127, 0, 0, 1);
}
String::from("127.0.0.1")
```

## Controle de fluxo com _match_

Vamos agora introduzir outro método de controle de fluxo, usaremos o `match`. Ele permite analisarmos valores e compará-los com certos padrões. O que torna perfeito para  analisar _enums_.

> Seria equivalente ao `switch-case` do C, Java, etc.

Veja o exemplo de utilização do `match`.

``` rust

enum Color {
    RED,
    BLUE,
    GREEN,
}

fn get_color_id(color: Color) -> u32 {
    match color {
        // Usamos a seguinte sintaxe: padrão => bloco/expressão
        // Exemplo com bloco
        Color::RED => {
            println!("RED");
            1
        },
        // Exemplo com expressão
        Color::BLUE => 2,

        Color::GREEN => 3
    }
}
```

E **lembre-se**, `match` é **exaustivo**, seu código não vai compilar a não ser que você cubra todos os casos possíveis, e para isso temos um __wildcard__, usamos `_` para aceitar qualquer padrão. Veja o exemplo usando números:

``` rust
let num = 10u32 // Um outro jeito de especificar o tipo de um número

match num {
    0 => {
        println!("Zero");
    },
    1 => {
        println!("Um!");
    },
    2..=8 => { // Para números você pode usar intervalos como padrões!
        println!("Entre 2 e 8 inclusivo!");
    },
    _ => { // Uso do _wildcard_, qualquer padrão que não passar pelos outros, cairá aqui
        println!("Cansei, é maior que 8");
    }
}

```

### Capturando valores

Pense novamente no exemplo dos endereços de IP, se você recebe um formato _IPV4_ você faz uma coisa, se for um formato _IPV6_ outra, e queremos não só diferenciar o tipo do endereço, mas também processar seus valores internos.

``` rust

enum IpAddress {
    V4(String),
    V6(String),
}

fn route(ip: IpAddress) {
    
    match ip {
        IpAddress::V4(addr) => {
            println!("IPV4 = {addr}");
        },
        IpAddress::V6(addr) => {
            println!("IPV6 = {addr}");
        }
    }
}

```

Isso é só o começo do `match`! Ele pode ser usado para criar padrões ainda mais complexos e variados. Infelizmente não cabe tudo isso neste pequeno tutorial, se você quer saber mais sobre isso consulte [a fonte](https://doc.rust-lang.org/stable/book/ch19-00-patterns.html)
