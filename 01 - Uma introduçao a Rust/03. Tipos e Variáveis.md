# Tipos e Vari√°veis

Agora que sabemos como criar e rodar nossos projetos, **vamos come√ßar** a aprender Rust pra valer!

## Declarando uma vari√°vel

Em toda linguagem de programa√ß√£o, temos vari√°veis: nossos pequenos armaz√©ns de informa√ß√£o. Para declarar uma vari√°vel no Rust, usamos a palavra reservada `let`:

```rust
fn main() {
    let x = 10;
    println!("x = {}", x);
}

```

Neste c√≥digo, criamos uma vari√°vel do tipo inteiro, e printamos ela na tela. O resultado esperado ser√° `x = 10`.

> Fazendo um adendo, a fun√ß√£o (macro) `println!` tem como primeiro parametro uma string literal de texto, por√©m ela tamb√©m aceita um n√∫mero vari√°vel de argumentos que v√£o ser formatados dentro do texto, e para inserir esses outros argumentos usamos duas chaves `{}`.

> E para voc√™ que est√° acostumado com C/C++, Rust consegue inferir tipos na maioria dos casos quando usamos `let`, assim como o `var` em Java.

## Vari√°veis Mut√°veis

Existe um pequeno detalhe n√£o dito anteriormente: `let` cria **vari√°veis imut√°veis**. Isto quer dizer que seu c√≥digo **n√£o vai compilar** se fizermos isso:

```rust
let x = 10;

x = 15;
```

Para criar vari√°veis que podemos alterar durante o programa, devemos adicionar a palavra chave `mut`.

```rust
let mut x = 10;
println!("x = {}", x);

x = 11;
println!("x = {}", x);
```

Agora sim, nosso c√≥digo compila e executa como queremos!

> O porqu√™ disso: Rust gosta de ser bem claro e espec√≠fico quanto √† inten√ß√£o do programador. Se voc√™ quer que algo seja mut√°vel, voc√™ __deve__ especificar. Assim, voc√™ ajuda quem est√° lendo seu c√≥digo, e previne _bugs_ acidentais, como alterando uma vari√°vel que n√£o deveria.


## Tipos Primitivos

Se voc√™ est√° acostumado com programa√ß√£o, j√° sabe o que s√£o tipos primitivos. Entre eles temos: n√∫meros inteiros, reais, strings e outros, vamos explora-los em Rust.

### Declara√ß√£o Expl√≠cita de tipos

Rust pode na maior parte das vezes inferir os tipos das vari√°veis. Por√©m, para tipos ou opera√ß√µes mais complexas, n√£o. Neste caso - ou se quisermos deixar bem claro o tipo de uma vari√°vel - podemos declarar explicitamente o tipo da vari√°vel.
```rust

let x: u32 = 18;
```

Vamos agora aprender sobre cada tipo.

### Tipo Inteiro

Para os inteiros Rust tem v√°rios tipos dependendo do quanto de mem√≥ria voc√™ quer utilizar. A linguagem difere inteiros entre _tamanho_ e _sinal_ (_unsigned_/_signed_), um tipo _signed_ pode ter valores negativos, enquanto um tipo _unsigned_ s√≥ pode ter valores positivos ou 0. Segue a lista de tipos:

| Tamanho | Signed | Unsigned |
| --- | --- | --- | 
| 8-bit | i8 | u8 |
| 16-bit | i16 | u16 |
| 32-bit | i32 | u32 |
| 64-bit | i64 | u64 |
| 128-bit | i128 | u128 |
| arch* | isize | usize |

> arch: refere-se a arquitetura do computador, x32 equivale a 32-bit, e x64 √† 64-bit. Isso foi escrito em 2025, ent√£o a n√£o ser que voc√™ esteja em um Macintosh, seu computador √© um x64.

O intervalo de n√∫meros para cada tipo segue a seguinte f√≥rmula: de $0$ a $2^n - 1$ para _unsigned_, e $- 2^{n-1}$ a $2^{n - 1} - 1$ para _signed_.

### Tipo Float

Temos 2 tipos de n√∫meros reais, `f32` para floats de 32-bit e `f64` para floats de 64-bit. Estes equivalem, respectivamente, aos tipos `float` e `double` em C, Java, etc.

### Tipo Booleano

Diferente do C, temos nativamente um tipo espec√≠fico para representar os estados VERDADEIRO e FALSO. No Rust, chamamos este tipo de `bool`, que assume somente dois valores: `true` e `false`.


### Tipo Character

Representa um caractere _UTF-8_ usando aspa √∫nica, diferente de aspas duplas que representam _strings_.

```rust
let c = 'z';

let emoji: char = 'ü¶Ä';
```

> ATEN√á√ÉO: Nem tudo que voc√™ **acha** que √© um caractere, realmente **√©** um caractere. Para aprender mais sobre o formato _UTF-8_, veja essa p√°gina: [UTF-8](https://pt.wikipedia.org/wiki/UTF-8)

### Tipo Array

Assim como a linguagem C, Rust tem um tipo array, neste caso, um array √© uma sequ√™ncia de tamanho _fixo_, e de tipo _homog√™neo_ (todo os valores tem o mesmo tipo).

```rust 

fn main() {
    let a: [u32; 5] = [1, 2, 3, 4, 5]; // Declara√ß√£o explicita do tipo √© opcional
    
    println!("= {}", a[0]); // O acesso ao array √© id√™ntico ao C
    // = 0
}

```

Acessar valores fora do array causa um _panic_, em outras palavras o programa encerra abrubtamente, para impedir acesso inv√°lido ou n√£o autorizado de mem√≥ria. Vamos explorar o _panic_ em outra se√ß√£o deste curso.


> Nota: em Rust, arrays **n√£o** decaem para ponteiros, se voc√™ n√£o programa em C, ignore essa mensagem.

### Tipo Tupla

Tupla √© um tipo usado para agrupar tipos juntos, atrav√©s de uma lista de tipos. Valores podem ser acessado por `.` ou a t√∫pla em si pode ser desestruturada em vari√°veis, o que √© √∫til para fun√ß√µes que retornam v√°rios valores.

```rust
fn main() {
    let tup: (i32, f64, bool) = (600, 3.2, false);

    println!("{}", tup.0); // 600

    let (x, y, z) = tup; 

    println!("{}", y); // 3.2
}
```


#### Tipo _Unit_ `()`

Como vimos antes, a fun√ß√£o _main_ retorna um tipo _unit_ que √© nada mais nada menos que uma t√∫pla vazia, indicando que o valor retornado tem tamanho _zero_. Ou seja, na pr√°tica nada √© retornado.

## Ap√™ndice: Constantes

Constantes no Rust s√£o parecidas com vari√°veis imut√°veis, por√©m com certas diferen√ßas. Elas podem ser declaradas no _escopo global_ (fora da fun√ß√£o _main_), e tem o poder de serem resolvidas em tempo de compila√ß√£o, parecidas com macros em C e `constexpr` no C++. Em outras palavras, se voc√™ quiser deixar um valor pr√©-calculado, voc√™ pode usar uma constante.

Elas devem ser declaradas da seguinte forma `const NOME: tipo = express√£o`, como no exemplo

```rust
const ONE_HOUR_IN_SECONDS: u32 = 60 * 60;
```

Assim, quando usarmos essa constante, o valor `3600` vai ser utilizado pelo programa.

> √â importante notar que nem tudo pode ser executado em tempo de compila√ß√£o. Coisas como opera√ß√µes artim√©ticas podem, mas outras como alocar mem√≥ria din√¢mica, n√£o.
