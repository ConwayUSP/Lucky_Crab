# Mexendo com Scripts

A partir daqui come√ßa a divers√£o de misturar Godot com Rust. Ent√£o iremos assumir que voc√™ seguiu todo o curso at√© aqui e possui tanto o rust quanto o godot instalados em seu computador. Caso voc√™ n√£o tenha, d√™ um passo para tr√°s e siga os passos dos nossos cap√≠tulos 1 da Introdu√ß√£o a Rust e da Introdu√ß√£o a Godot.

## Linguagens de Script

O Godot oficialmente suporta apenas 4 linguagens: GDScript (uma linguagem criada especificamente para a engine), C#, C++ e C. Contudo, atrav√©s de uma tecnologia chamada GDExtension, a comunidade √© provida com as ferramentas para adicionar suporte a outras linguagens, como √© o caso do [Rust](https://godot-rust.github.io/book/).

## A Estrutura do Projeto

A organiza√ß√£o de pastas e arquivos de um projeto em "godot-rust" ser√° um combo das organiza√ß√µes de um projeto godot com um projeto rust, como √© de se imaginar. A hierarquia de pastas ficar√° assim:

```
üìÇ project
‚îÇ
‚îú‚îÄ‚îÄ üìÇ .git
‚îÇ
‚îú‚îÄ‚îÄ üìÇ godot
‚îÇ   ‚îú‚îÄ‚îÄ üìÇ .godot
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ HelloWorld.gdextension
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ project.godot
‚îÇ
‚îî‚îÄ‚îÄ üìÇ rust
    ‚îú‚îÄ‚îÄ üìÑ Cargo.toml
    ‚îú‚îÄ‚îÄ üìÇ src
    ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ lib.rs
    ‚îî‚îÄ‚îÄ üìÇ target
        ‚îî‚îÄ‚îÄ üìÇ debug
```

Para chegar em uma estrutura como essa, siga os seguintes passos:

1. Crie um diret√≥rio para a base do projeto com o comando `mkdir nome_do_projeto`;
2. Se quiser, inicialize seu reposit√≥rio git neste diret√≥rio;
3. Abra o Godot e crie um projeto neste mesmo reposit√≥rio, para manter a estrutura acima, nomeie seu projeto "godot";
4. Inicie um projeto rust no diret√≥rio base com o comando `cargo new "rust" --lib`. Colocando o nome da biblioteca como "rust" apenas para seguir a estrutura acima tamb√©m.

## Preparando a base

Agora que nosso projeto tem uma estrutura de arquivos bacana, podemos come√ßar a adicionar as pe√ßas que faltam para que tudo se encaixe perfeitamente.

A primeira coisa que faremos √© adicionar o seguinte conte√∫do ao `cargo.toml`:

``` toml
[lib]
crate-type = ["cdylib"]
```

Isto far√° com que, quando rodarmos `cargo build`, nosso c√≥digo em rust seja compilado para uma biblioteca din√¢mica em C, ao inv√©s de um bin√°rio.

Al√©m disso, iremos colocar o nome do nosso projeto aqui:

``` toml
[package]
name = "Nome_do_Projeto"
```

No meu caso, vou colocar `name = "rustgame"`. Ap√≥s isso, vamos rodar o comando `cargo add godot` no terminal, estando no nosso diret√≥rio "rust". isso ir√° adicionar a depend√™ncia **godot** ao nosso projeto, o que √© extremamente importante para que possamos usar as funcionalidades do GDExtension em nosso c√≥digo. Ao final dessas etapas, seu cargo.toml deve estar mais ou menos assim:

``` toml
[package]
name = "rustgame"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib"]

[dependencies]
godot = "0.2.4"
```

Agora que cuidamos das coisas no lado do Rust, precisamos fazer a conex√£o do lado do Godot. Para isso, vamos criar na pasta `godot` um arquivo com extens√£o `.gdextension`. Chamemos ele de `HelloWorld.gdextension`, por exemplo. Dentro dele, precisamos colocar o seguinte conte√∫do:

``` toml
[configuration]
entry_symbol = "gdext_rust_init"
compatibility_minimum = 4.1
reloadable = true

[libraries]
linux.debug.x86_64 =     "res://../rust/target/debug/lib{Projeto}.so"
linux.release.x86_64 =   "res://../rust/target/release/lib{Projeto}.so"
windows.debug.x86_64 =   "res://../rust/target/debug/{Projeto}.dll"
windows.release.x86_64 = "res://../rust/target/release/{Projeto}.dll"
macos.debug =            "res://../rust/target/debug/lib{Projeto}.dylib"
macos.release =          "res://../rust/target/release/lib{Projeto}.dylib"
macos.debug.arm64 =      "res://../rust/target/debug/lib{Projeto}.dylib"
macos.release.arm64 =    "res://../rust/target/release/lib{Projeto}.dylib"
```

Substituindo `{Projeto}` nos caminhos acima com o nome do seu projeto que voc√™ colocou no cargo.toml. No meu caso era "rustgame", ent√£o ficaria assim:

``` toml
[configuration]
entry_symbol = "gdext_rust_init"
compatibility_minimum = 4.1
reloadable = true

[libraries]
linux.debug.x86_64 =     "res://../rust/target/debug/librustgame.so"
linux.release.x86_64 =   "res://../rust/target/release/librustgame.so"
windows.debug.x86_64 =   "res://../rust/target/debug/rustgame.dll"
windows.release.x86_64 = "res://../rust/target/release/rustgame.dll"
macos.debug =            "res://../rust/target/debug/librustgame.dylib"
macos.release =          "res://../rust/target/release/librustgame.dylib"
macos.debug.arm64 =      "res://../rust/target/debug/librustgame.dylib"
macos.release.arm64 =    "res://../rust/target/release/librustgame.dylib"
```

Vamos entender o que est√° acontecendo aqui:

- O `entry_symbol` √© o ponto de entrada definido pela extens√£o gd do rust, ent√£o n√£o mexeremos em seu valor.
- A compatibilidade m√≠nima (`compatibility_minimum`) √© a vers√£o do Godot que nosso projeto espera para poder compilar. Qualquer pessoa tentando compilar nosso c√≥digo em rust mas que estiver usando uma vers√£o mais antiga do Godot obter√° um erro.
- `reloadable` √© uma op√ß√£o que diz se o editor do Godot deveria recarregar a extens√£o quando a janela entrar em foco. Isso √© √∫til para que o editor do Godot fique sempre atualizado com nosso c√≥digo em Rust conforme n√≥s vamos modificando-o e recompilando-o. √â poss√≠vel que esta op√ß√£o cause crashes no seu editor, ent√£o se for o caso, desative-a.
- As `[libraries]` s√£o caminhos para os arquivos de biblioteca din√¢mica gerados ao rodarmos `cargo build`. Estes caminhos utilizam um padr√£o pr√≥prio do Godot, e √© por isso que utilizam o prefixo `"res://"` e s√£o relativos √† pasta `godot`.

Ok, se voc√™ abrir o projeto agora no editor do Godot, um arquivo chamado `extension_list.cfg` deve ser gerada na pasta `godot/.godot/`. Caso isto n√£o ocorra, voc√™ pode criar este arquivo manualmente, e colocar nele apenas a seguinte linha, com o caminho para o `.gdextension` que acabamos de criar:

```
res://HelloWorld.gdextension
```

Se, ao abrir o godot, voc√™ notar no terminal um monte de erros dizendo que o arquivo `HelloWorld.gdextension` n√£o foi encontrado, n√£o entre em p√¢nico, isto √© normal por enquanto, os erros v√£o sumir at√© o fim deste cap√≠tulo.

## Escrevendo os Scripts

Agora bora finalmente para a parte de escrever nossos scripts em Rust. Em nosso lib.rs vamos colocar o seguinte c√≥digo:

``` rust
// importa os principais s√≠mbolos da API do godot
use godot::prelude::*;

// Cria uma estrutura vazia para nossa extens√£o
// Voc√™ pode nome√°-la como quiser
struct MyExtension;

// Marca nossa estrutura com o atributo #[gdextension]
// E implementa o trait ExtensionLibrary para ela
#[gdextension]
unsafe impl ExtensionLibrary for MyExtension {}
```

Tudo isso √© _boilerplate_. A divers√£o come√ßa de fato quando criamos uma classe no Rust que poder√° ser usada como n√≥ dentro do Godot, que √© o que faremos agora.

Primeiro iremos criar um arquivo `player.rs` na mesma pasta que o `lib.rs`. Nele, iremos colocar o seguinte c√≥digo:

``` rust
// Importa o que usaremos para implementar nosso jogador
use godot::prelude::*;
use godot::classes::Sprite2D;

// Declaramos o Player como sendo uma classe do Godot
// E fazemos ele "herdar" de Sprite2D. Ou seja, Player agora √© um "n√≥ filho" de Sprite2D, como voc√™ poder√° ver em breve no editor.
#[derive(GodotClass)]
#[class(base=Sprite2D)]
struct Player {
    speed: f64, 		 // Velocidade do jogador 
    angular_speed: f64,  // Velocidade angular do jogador

    base: Base<Sprite2D> // Nos permite acessar a classe base do jogador, neste caso, Sprite2D
}
```

Essa classe ainda n√£o faz nada, ou sequer compila, pela falta de um construtor para Player, ent√£o vamos resolver isso, adicionando o seguinte c√≥digo:

``` rust
// Importando a interface para os comportamentos de Sprite2D, incluindo a fun√ß√£o init
// Cada classe tem um I{nome_da_classe} com suas funcionalidades
use godot::classes::ISprite2D;

// O #[godot_api] indica para o Godot que esta implementa√ß√£o √© parte da API que estamos expondo para ele
#[godot_api]
impl ISprite2D for Player {
	// Declarando o constutor do Player com alguns valores padr√£o e uma mensagem no console do godot
    fn init(base: Base<Sprite2D>) -> Self {
        godot_print!("Hello, world!");
        
        Self {
            speed: 400.0,
            angular_speed: std::f64::consts::PI,
            base,
        }
    }
}
```

Abaixo da fun√ß√£o `init()`, vamos adicionar mais uma fun√ß√£o para que haja algum movimento na tela quando rodarmos o jogo - s√≥ para sabermos que est√° tudo rodando normalmente:

``` rust
fn physics_process(&mut self, delta: f64) {
    let radians = (self.angular_speed * delta) as f32;
    self.base_mut().rotate(radians);

    let rotation = self.base().get_rotation();
    let velocity = Vector2::UP.rotated(rotation) * self.speed as f32;
    self.base_mut().translate(velocity * delta as f32);
}
```

E por fim, n√£o podemos esquecer de colocar a linha `mod player;` no come√ßo do `lib.rs` para que a biblioteca encontre a classe do nosso jogador.

Com tudo isso feito, podemos reabrir o nosso projeto no Godot (n√£o sem antes compil√°-lo com `cargo build`, √© claro).

Dentro do editor, que est√° atualmente vazio, crie uma cena 2d qualquer, e depois tente incluir nela um n√≥ do tipo `Player`. Ele estar√° como um filho de Sprite2D, como na imagem abaixo.

![n√≥ Player](../assets/no_player.png) 

Sua cena deve ficar assim:

![Cena com Player](../assets/cena_com_player.png)

Agora, para que o nosso jogador seja vis√≠vel, vamos dar um corpo a ele, como por exemplo o asset padr√£o do rob√¥zinho do Godot. Para fazer isso, basta que voc√™ arraste a imagem do rob√¥zinho da aba `FileSystem` no canto inferior esquerdo para a propriedade *Texture* do Player, na aba `Inspector` no canto superior direito. Agora posicione o jogador no centro da tela, como na imagem abaixo:

![cena com o jogador no centro](../assets/visible_player.png)

E finalmente voc√™ pode rodar o projeto!!! O comportamento esperado √© que o rob√¥ fique girando em sentido hor√°rio ao redor de onde voc√™ o posicionou.

## Conclus√£o

Se voc√™ est√° encomodado com a falta de explica√ß√µes e aprofundamento sobre os c√≥digos que voc√™ "copiou e colou" ao longo deste cap√≠tulo, segura firme. O objetivo deste cap√≠tulo era apenas que n√≥s juntassemos algumas pe√ßas para obter uma integra√ß√£o m√≠nima entre o Godot e o Rust. Nos pr√≥ximos cap√≠tulos explicaremos tudo em mais detalhes e ent√£o os c√≥digos come√ßar√£o a fazer mais sentido (provavelmente).

Ufaaa... foi um tanto trabalhoso n√©? A boa not√≠cia √© que a maior parte foi s√≥ um monte de etapas preparat√≥rias que s√≥ precisamos fazer uma vez por projeto. Nos cap√≠tulos seguintes iremos nos aprofundar mais na API do Godot para Rust, e explorar os verdadeiros poderes dessa dupla letal. At√© l√°! :D