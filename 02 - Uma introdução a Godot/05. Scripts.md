# Mexendo com Scripts

A partir daqui comeÃ§a a diversÃ£o de misturar Godot com Rust. EntÃ£o iremos assumir que vocÃª seguiu todo o curso atÃ© aqui e possui tanto o rust quanto o godot instalados em seu computador. Caso vocÃª nÃ£o tenha, dÃª um passo para trÃ¡s e siga os passos dos nossos capÃ­tulos 1 da IntroduÃ§Ã£o a Rust e da IntroduÃ§Ã£o a Godot.

## Linguagens de Script

O Godot oficialmente suporta apenas 4 linguagens: GDScript (uma linguagem criada especificamente para a engine), C#, C++ e C. Contudo, atravÃ©s de uma tecnologia chamada GDExtension, a comunidade Ã© provida com as ferramentas para adicionar suporte a outras linguagens, como Ã© o caso do [Rust](https://godot-rust.github.io/book/).

## A Estrutura do Projeto

A organizaÃ§Ã£o de pastas e arquivos de um projeto em "godot-rust" serÃ¡ um combo das organizaÃ§Ãµes de um projeto godot com um projeto rust, como Ã© de se imaginar. A hierarquia de pastas ficarÃ¡ assim:

```
ğŸ“‚ project
â”‚
â”œâ”€â”€ ğŸ“‚ .git
â”‚
â”œâ”€â”€ ğŸ“‚ godot
â”‚   â”œâ”€â”€ ğŸ“‚ .godot
â”‚   â”œâ”€â”€ ğŸ“„ HelloWorld.gdextension
â”‚   â””â”€â”€ ğŸ“„ project.godot
â”‚
â””â”€â”€ ğŸ“‚ rust
    â”œâ”€â”€ ğŸ“„ Cargo.toml
    â”œâ”€â”€ ğŸ“‚ src
    â”‚   â””â”€â”€ ğŸ“„ lib.rs
    â””â”€â”€ ğŸ“‚ target
        â””â”€â”€ ğŸ“‚ debug
```

Para chegar em uma estrutura como essa, siga os seguintes passos:

1. Crie um diretÃ³rio para a base do projeto com o comando `mkdir nome_do_projeto`;
2. Se quiser, inicialize seu repositÃ³rio git neste diretÃ³rio;
3. Abra o Godot e crie um projeto neste mesmo repositÃ³rio, para manter a estrutura acima, nomeie seu projeto "godot";
4. Inicie um projeto rust no diretÃ³rio base com o comando `cargo new "rust" --lib`. Colocando o nome da biblioteca como "rust" apenas para seguir a estrutura acima tambÃ©m.

## Preparando a base

Agora que nosso projeto tem uma estrutura de arquivos bacana, podemos comeÃ§ar a adicionar as peÃ§as que faltam para que tudo se encaixe perfeitamente.

A primeira coisa que faremos Ã© adicionar o seguinte conteÃºdo ao `cargo.toml`:

``` toml
[lib]
crate-type = ["cdylib"]
```

Isto farÃ¡ com que, quando rodarmos `cargo build`, nosso cÃ³digo em rust seja compilado para uma biblioteca dinÃ¢mica em C, ao invÃ©s de um binÃ¡rio.

AlÃ©m disso, iremos colocar o nome do nosso projeto aqui:

``` toml
[package]
name = "Nome_do_Projeto"
```

No meu caso, vou colocar `name = "rustgame"`. ApÃ³s isso, vamos rodar o comando `cargo add godot` no terminal, estando no nosso diretÃ³rio "rust". isso irÃ¡ adicionar a dependÃªncia **godot** ao nosso projeto, o que Ã© extremamente importante para que possamos usar as funcionalidades do GDExtension em nosso cÃ³digo. Ao final dessas etapas, seu cargo.toml deve estar mais ou menos assim:

``` toml
[package]
name = "rustgame"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib"]

[dependencies]
godot = "0.2.4"
```

Agora que cuidamos das coisas no lado do Rust, precisamos fazer a conexÃ£o do lado do Godot. Para isso, vamos criar na pasta `godot` um arquivo com extensÃ£o `.gdextension`. Chamemos ele de `HelloWorld.gdextension`, por exemplo. Dentro dele, precisamos colocar o seguinte conteÃºdo:

``` toml
[configuration]
entry_symbol = "gdext_rust_init"
compatibility_minimum = 4.1
reloadable = true

[libraries]
linux.debug.x86_64 =     "res://../rust/target/debug/lib{Projeto}.so"
linux.release.x86_64 =   "res://../rust/target/release/lib{Projeto}.so"
windows.debug.x86_64 =   "res://../rust/target/debug/{Projeto}.dll"
windows.release.x86_64 = "res://../rust/target/release/{Projeto}.dll"
macos.debug =            "res://../rust/target/debug/lib{Projeto}.dylib"
macos.release =          "res://../rust/target/release/lib{Projeto}.dylib"
macos.debug.arm64 =      "res://../rust/target/debug/lib{Projeto}.dylib"
macos.release.arm64 =    "res://../rust/target/release/lib{Projeto}.dylib"
```

Substituindo `{Projeto}` nos caminhos acima com o nome do seu projeto que vocÃª colocou no cargo.toml. No meu caso era "rustgame", entÃ£o ficaria assim:

``` toml
[configuration]
entry_symbol = "gdext_rust_init"
compatibility_minimum = 4.1
reloadable = true

[libraries]
linux.debug.x86_64 =     "res://../rust/target/debug/librustgame.so"
linux.release.x86_64 =   "res://../rust/target/release/librustgame.so"
windows.debug.x86_64 =   "res://../rust/target/debug/rustgame.dll"
windows.release.x86_64 = "res://../rust/target/release/rustgame.dll"
macos.debug =            "res://../rust/target/debug/librustgame.dylib"
macos.release =          "res://../rust/target/release/librustgame.dylib"
macos.debug.arm64 =      "res://../rust/target/debug/librustgame.dylib"
macos.release.arm64 =    "res://../rust/target/release/librustgame.dylib"
```

Vamos entender o que estÃ¡ acontecendo aqui:

- O `entry_symbol` Ã© o ponto de entrada definido pela extensÃ£o gd do rust, entÃ£o nÃ£o mexeremos em seu valor.
- A compatibilidade mÃ­nima (`compatibility_minimum`) Ã© a versÃ£o do Godot que nosso projeto espera para poder compilar. Qualquer pessoa tentando compilar nosso cÃ³digo em rust mas que estiver usando uma versÃ£o mais antiga do Godot obterÃ¡ um erro.
- `reloadable` Ã© uma opÃ§Ã£o que diz se o editor do Godot deveria recarregar a extensÃ£o quando a janela entrar em foco. Isso Ã© Ãºtil para que o editor do Godot fique sempre atualizado com nosso cÃ³digo em Rust conforme nÃ³s vamos modificando-o e recompilando-o. Ã‰ possÃ­vel que esta opÃ§Ã£o cause crashes no seu editor, entÃ£o se for o caso, desative-a.
- As `[libraries]` sÃ£o caminhos para os arquivos de biblioteca dinÃ¢mica gerados ao rodarmos `cargo build`. Estes caminhos utilizam um padrÃ£o prÃ³prio do Godot, e Ã© por isso que utilizam o prefixo `"res://"` e sÃ£o relativos Ã  pasta `godot`.

Ok, se vocÃª abrir o projeto agora no editor do Godot, um arquivo chamado `extension_list.cfg` deve ser gerada na pasta `godot/.godot/`. Caso isto nÃ£o ocorra, vocÃª pode criar este arquivo manualmente, e colocar nele apenas a seguinte linha, com o caminho para o `.gdextension` que acabamos de criar:

```
res://HelloWorld.gdextension
```

Se, ao abrir o godot, vocÃª notar no terminal um monte de erros dizendo que o arquivo `HelloWorld.gdextension` nÃ£o foi encontrado, nÃ£o entre em pÃ¢nico, isto Ã© normal por enquanto, os erros vÃ£o sumir atÃ© o fim deste capÃ­tulo.

## Escrevendo os Scripts

Agora bora finalmente para a parte de escrever nossos scripts em Rust. Em nosso lib.rs vamos colocar o seguinte cÃ³digo:

``` rust
// importa os principais sÃ­mbolos da API do godot
use godot::prelude::*;

// Cria uma estrutura vazia para nossa extensÃ£o
// VocÃª pode nomeÃ¡-la como quiser
struct MyExtension;

// Marca nossa estrutura com o atributo #[gdextension]
// E implementa o trait ExtensionLibrary para ela
#[gdextension]
unsafe impl ExtensionLibrary for MyExtension {}
```

Tudo isso Ã© _boilerplate_. A diversÃ£o comeÃ§a de fato quando criamos uma classe no Rust que poderÃ¡ ser usada como nÃ³ dentro do Godot, que Ã© o que faremos agora.

Primeiro iremos criar um arquivo `player.rs` na mesma pasta que o `lib.rs`. Nele, iremos colocar o seguinte cÃ³digo:

``` rust
// Importa o que usaremos para implementar nosso jogador
use godot::prelude::*;
use godot::classes::Sprite2D;

// Declaramos o Player como sendo uma classe do Godot
// E fazemos ele "herdar" de Sprite2D. Ou seja, Player agora Ã© um "nÃ³ filho" de Sprite2D, como vocÃª poderÃ¡ ver em breve no editor.
#[derive(GodotClass)]
#[class(base=Sprite2D)]
struct Player {
    speed: f64, 		 // Velocidade do jogador 
    angular_speed: f64,  // Velocidade angular do jogador

    base: Base<Sprite2D> // Nos permite acessar a classe base do jogador, neste caso, Sprite2D
}
```

Essa classe ainda nÃ£o faz nada, ou sequer compila, pela falta de um construtor para Player, entÃ£o vamos resolver isso, adicionando o seguinte cÃ³digo:

``` rust
// Importando a interface para os comportamentos de Sprite2D, incluindo a funÃ§Ã£o init
// Cada classe tem um I{nome_da_classe} com suas funcionalidades
use godot::classes::ISprite2D;

// O #[godot_api] indica para o Godot que esta implementaÃ§Ã£o Ã© parte da API que estamos expondo para ele
#[godot_api]
impl ISprite2D for Player {
	// Declarando o constutor do Player com alguns valores padrÃ£o e uma mensagem no console do godot
    fn init(base: Base<Sprite2D>) -> Self {
        godot_print!("Hello, world!");
        
        Self {
            speed: 400.0,
            angular_speed: std::f64::consts::PI,
            base,
        }
    }
}
```

Abaixo da funÃ§Ã£o `init()`, vamos adicionar mais uma funÃ§Ã£o para que haja algum movimento na tela quando rodarmos o jogo - sÃ³ para sabermos que estÃ¡ tudo rodando normalmente:

``` rust
fn physics_process(&mut self, delta: f64) {
    let radians = (self.angular_speed * delta) as f32;
    self.base_mut().rotate(radians);

    let rotation = self.base().get_rotation();
    let velocity = Vector2::UP.rotated(rotation) * self.speed as f32;
    self.base_mut().translate(velocity * delta as f32);
}
```

E por fim, nÃ£o podemos esquecer de colocar a linha `mod player;` no comeÃ§o do `lib.rs` para que a biblioteca encontre a classe do nosso jogador.

Com tudo isso feito, podemos reabrir o nosso projeto no Godot (nÃ£o sem antes compilÃ¡-lo com `cargo build`, Ã© claro).

Dentro do editor, que estÃ¡ atualmente vazio, crie uma cena 2d qualquer, e depois tente incluir nela um nÃ³ do tipo `Player`. Ele estarÃ¡ como um filho de Sprite2D, como na imagem abaixo.

![nÃ³ Player](../assets/no_player.png) 

Sua cena deve ficar assim:

![Cena com Player](../assets/cena_com_player.png)

Agora, para que o nosso jogador seja visÃ­vel, vamos dar um corpo a ele, como por exemplo o asset padrÃ£o do robÃ´zinho do Godot. Para fazer isso, basta que vocÃª arraste a imagem do robÃ´zinho da aba `FileSystem` no canto inferior esquerdo para a propriedade *Texture* do Player, na aba `Inspector` no canto superior direito. Agora posicione o jogador no centro da tela, como na imagem abaixo:

![cena com o jogador no centro](../assets/visible_player.png)

E finalmente vocÃª pode rodar o projeto!!! O comportamento esperado Ã© que o robÃ´ fique girando em sentido horÃ¡rio ao redor de onde vocÃª o posicionou.

Ufaaa... foi um tanto trabalhoso nÃ©? A boa notÃ­cia Ã© que a maior parte foi sÃ³ um monte de etapas preparatÃ³rias que sÃ³ precisamos fazer uma vez por projeto. Nos capÃ­tulos seguintes iremos nos aprofundar mais na API do Godot para Rust, e explorar os verdadeiros poderes dessa dupla letal. AtÃ© lÃ¡! :D