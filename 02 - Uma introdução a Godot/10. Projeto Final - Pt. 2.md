# 10. Projeto Final - Parte 2

Olá, bem-vindo de volta! No último capítulo você configurou o projeto final e criou as entidades jogador e inimigo, agora nós vamos juntar as cenas e criar a lógica principal do nosso jogo. Preparado? Espero que sim!

## Cena Principal

Vamos criar nossa cena principal, crie um arquivo chamado `main_game.rs` e declare o módulo em `lib.rs`. Insira o _boilerplate_ no arquivo recém criado, nosso nó irá herdar de `Node`.

```rust
/// main_game.rs
use godot::prelude::*;
use godot::classes::Node;

#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    base: Base<Node>
}

#[godot_api]
impl INode for Main {
    fn init(base: Base<Self::Base>) -> Self {
        Self {
            base,
        }
    }
}
```

Compile a biblioteca novamente, e crie uma nova cena no Godot, o nó raiz deve ser `Main`. Crie uma **instância** apertando o botão em formato de corrente e selecione `player.tscn`. Desse modo, alterações na cena do jogador serão expostas na cena principal. Agora adicione os seguintes nós como filhos da `Main`:

- `Timer` nomeado como `MobTimer`, para controlar o tempo que os inimigos vão spawnat
- `Timer` nomeado como `ScoreTimer`, para incrementar a pontuação do jogo
- `Timer` nomeado como `StartTimer`, para dar um delay nos spawns antes do jogo começar
- `Marker2D` nomeado como `StartPosition` indicando onde o jogador vai spawnar

Em cada temporizador, configure a propriedade `WaitTime` do seguinte modo:

- `MobTimer`: $0.5$
- `ScoreTimer`: $1$
- `StartTimer`: $2$

Além disso, `StartTime` deve ter a propriedade `OneShot` ativada, e `StartPosition` deve ter `Position` setado para `(240, 450)`.

> `Timer` é um nó **temporizador**, uma vez completado seu `wait_time` (tempo de espera) ele emite um sinal de `timeout`, podendo ser reiniciado com a função `start`, leia mais em [Timer - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_timer.html#class-timer).

> `Marker2D` representa uma posição em um plano 2D, é apenas um encapsulamento de `Node2D` mas ele mostra uma marcação ~~duh~~ no editor do Godot, leia mais em [Marker2D - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_marker2d.html#class-marker2d).

### Spawnar inimigos

Queremos spawnar nossos inimigos em pontos aleatório ao redor da borda da tela, para fazer isso, vamos traçar um caminho de onde podemos selecionar pontos aleatórios. Crie um nó do tipo `Path2D` nomeado `MobPath`, ao selecionar esse nó, um novo conjunto de botões vai aparecer no topo do editor.

<img width="827" height="71" alt="image" src="https://github.com/user-attachments/assets/363fcc1d-27c5-402d-94c9-c1cf9687493d" />

Selecione o botão "_Add point_", ative as opções "_Use grid snap_" e "_Use smart snap_", ambos são ícones com um imã, isso vai ajudar a marcar os pontos mais precisamente. Agora clique em cada um dos pontos da tela do seu jogo (o retângulo caso você não tenha percebido) e aperte o botão "_Close curve_". Agora adicione um nó do tipo `PathFollow2D` como filho de `MobPath` e nomeie-o `MobSpawnLocation`, um caminho de setas em sentido horário (isso é importante!) vai aparecer. E isso é tudo que precisamos, esse deve ser o produto final da sua cena.

<img width="300" height="400" alt="image" src="https://github.com/user-attachments/assets/1188702c-6d0e-4b50-ae27-a717da294530" />
<img width="300" height="400" alt="image" src="https://github.com/user-attachments/assets/3fd63114-6e3b-4894-b022-4b3ecf72efb1" />

> `Path2D`, uma curva (encapsula `Curve2D`) para um `PathFollow2D` seguir. `PathFollow2D` retorna as coordenadas de um ponto dentro do caminho de `Path2D` com base na distância do primeiro vértice. Permite criar caminhos sem programar padrões de movimento. Leia mais em [Path2D - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_path2d.html#class-path2d).

### Criando nosso scripts

Vamos programar nossa cena, abra novamente `main_game.rs` e adicione os seguintes campos a sua estrutura.
```rust
#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    mob_scene: OnReady<Gd<PackedScene>>,
    player: OnReady<Gd<Player>>,

    score: u32,
    base: Base<Node>
}
```
E atualize a função `init` para incluir esses novos campos.
```rust
fn init(base: Base<Self::Base>) -> Self {
    Self {
        mob_scene: OnReady::from_loaded("res://mob.tscn"),
        player: OnReady::from_node("Player"),
        score: 0,
        base
    } 
}
```

Adicionamos nossa pontuação (`score`), nosso `player` e `mob_scene` são para acessar nosso jogador e nossos inimigos de modo mais rápido, utilizamos `OnReady` para inicializar esses valores quando estiverem disponíveis. `PackedScene` nos permite escolher qual inimigo do conjunto spawnado queremos instanciar. Vamos criar duas funções, para iniciar o jogo e outra para encerrá-lo.

```rust

#[godot_api]
impl Main {
    // Nenhuma dessas funções será usada pelo Godot então não temos que adicionar o macro `#[func]`
    // encerra o jogo
    fn game_over(&mut self) {
        // TODO: parar o mob spawn
        // TODO: parar o incremento do score
    } 

    // começa um novo jogo
    fn new_game(&mut self) {
        // TODO: começar o mob spawn
        // TODO: começar o incremento do score
    }
}
```
Acessaremos os nós filhos da nossa cena com bastante frequência, então vamos criar funções utilitárias para nos ajudar com isso, ainda dentro do bloco `impl` escreveremos o seguinte código:
```rust
fn start_position(&self) -> Gd<Marker2D> {
    self.base().get_node_as::<Marker2D>("StartPosition")
}

fn score_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("ScoreTimer")
}

fn start_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("StartTimer")
}

fn mob_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("MobTimer")
}
```
Muito bem, agora podemos implementar as duas funções anteriores.

```rust
fn game_over(&mut self) {
    self.score_timer().stop();
    self.mob_timer().stop();
}

fn new_game(&mut self) {
    let start_pos = self.start_position().get_position();
    self.player.bind_mut().start(start_pos);
    
    self.start_timer().start();
}
```

Em `game_over`, paramos os temporizadores da pontuação e dos inimigos, já em `new_game`, pegamos o valor do nó `StartPosition` e inicializamos o jogador. Lembra da função `start` definida em `Player`? Estamos usando ela mesma, adicione a palavra-chave `pub` para torná-la visível a nossa cena. Também iniciamos o nó `StartTimer` para dar um delay antes da lógica do jogo começar e dar um tempo para o jogador se preparar. Vamos definir funções para quando os temporizadores encerrarem. Crie um funções para cada timer: `on_mob_timer_timeout`, `on_start_timer_timeout` e `on_score_timer_timeout`. Veja as implementações de cada uma.

```rust
#[func]
fn on_score_timer_timeout(&mut self) {
    self.score += 1;
}
```
Não tenho nem o que dizer sobre essa função.

```rust
#[func]
fn on_start_timer_timeout(&mut self) {
    self.score_timer().start();
    self.mob_timer().start();
}
```
Quando o temporizador acabar iniciamos o temporizador da pontuação e o temporizador de spawn de inimigos. ~~Estou falando muito temporizador.~~

```rust
#[func]
fn on_mob_timer_timeout(&mut self) {

    let mut mob_spawn_location = self.base().get_node_as::<PathFollow2D>("MobPath/MobSpawnLocation");
    let mut mob_scene = self.mob_scene.instantiate_as::<Mob>();

    let progress = rand::random_range(u32::MIN..u32::MAX) as f32;
    mob_spawn_location.set_progress(progress);
    mob_scene.set_position(mob_spawn_location.get_position());

    // apontamos o inimigo para o centro da tela
    let mut direction = mob_spawn_location.get_rotation() + std::f32::consts::PI / 2.0;
    // variamos a direção do movimento em 45º para + ou -
    direction += rand::random_range((-std::f32::consts::PI / 4.0)..std::f32::consts::PI/4.0);
    mob_scene.set_rotation(direction);

    // velocidade do inimigo é escolhida aleatoriamente
    let velocity = Vector2::new(rand::random_range(150..200) as f32, 0.0);
    mob_scene.set_linear_velocity(velocity.rotated(direction));

    self.base_mut().add_child(&mob_scene);
}
```
Essa função é a mais longa, primeiro criamos uma instância de `Mob`, pegamos uma posição aleatória de `MobSpawnLocation` e definimos como posição do inimigo. Depois pegamos a direção pré existente do caminho que estamos seguindo e viramos ela em $90º$ (para dentro da tela, se no sentindo horário), com uma certa aleatoriedade na direção. Por fim, escolhemos uma velocidade aleatória para o inimigo e adicionamos ele a cena principal. 

Concluindo essa parte, temos que conectar nossas funções aos sinais emitidos pelo Godot. Crie a função `ready` dentro do bloco `impl INode for Main`. Conecte o sinal de `timeout` dos temporizador com as funções de _timeout_, bem como, conecte o sinal de `hit` do jogador com a função `game_over`. Para isso será preciso tornar a função `hit` pública.

```rust
fn ready(&mut self) {
    let game = self.to_gd();

    // se o jogador for atingido o jogo acaba
    self.player
        .signals()
        .hit()
        .connect_other(&game, Self::game_over);

    self.start_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_start_timer_timeout);

    self.mob_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_mob_timer_timeout);

    self.score_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_score_timer_timeout);
} 
```
Temos boa parte da lógica da cena feita, se quiser testar, chame `new_game` no final de `ready` e rode a cena principal, os inimigos vão _spawnar_ e se você encostar neles você morre! 

## Criando a UI

<img width="293" height="331" alt="image" src="https://github.com/user-attachments/assets/aae2c09c-6f2d-4961-accb-01e438552c05" />

<img width="390" height="562" alt="image" src="https://github.com/user-attachments/assets/0a53d79b-3c83-48d0-9854-6bbae29c5543" />

