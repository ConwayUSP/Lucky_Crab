# 10. Projeto Final - Parte 2

Olá, bem-vindo de volta! No último capítulo você configurou o projeto final e criou as entidades jogador e inimigo, agora nós vamos juntar as cenas e criar a lógica principal do nosso jogo. Preparado? Espero que sim!

## Cena Principal

Vamos criar nossa cena principal, crie um arquivo chamado `main_game.rs` e declare o módulo em `lib.rs`. Insira o _boilerplate_ no arquivo recém criado, nosso nó irá herdar de `Node`.

```rust
/// main_game.rs
use godot::prelude::*;
use godot::classes::Node;

#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    base: Base<Node>
}

#[godot_api]
impl INode for Main {
    fn init(base: Base<Self::Base>) -> Self {
        Self {
            base,
        }
    }
}
```

Compile a biblioteca novamente, e crie uma nova cena no Godot, o nó raiz deve ser `Main`. Crie uma **instância** apertando o botão em formato de corrente e selecione `player.tscn`. Desse modo, alterações na cena do jogador serão expostas na cena principal. Agora adicione os seguintes nós como filhos da `Main`:

- `Timer` nomeado como `MobTimer`, para controlar o tempo que os inimigos vão spawnat
- `Timer` nomeado como `ScoreTimer`, para incrementar a pontuação do jogo
- `Timer` nomeado como `StartTimer`, para dar um delay nos spawns antes do jogo começar
- `Marker2D` nomeado como `StartPosition` indicando onde o jogador vai spawnar

Em cada temporizador, configure a propriedade `WaitTime` do seguinte modo:

- `MobTimer`: $0.5$
- `ScoreTimer`: $1$
- `StartTimer`: $2$

Além disso, `StartTime` deve ter a propriedade `OneShot` ativada, e `StartPosition` deve ter `Position` setado para `(240, 450)`.

> `Timer` é um nó **temporizador**, uma vez completado seu `wait_time` (tempo de espera) ele emite um sinal de `timeout`, podendo ser reiniciado com a função `start`, leia mais em [Timer - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_timer.html#class-timer).

> `Marker2D` representa uma posição em um plano 2D, é apenas um encapsulamento de `Node2D` mas ele mostra uma marcação ~~duh~~ no editor do Godot, leia mais em [Marker2D - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_marker2d.html#class-marker2d).

### Spawnar inimigos

Queremos spawnar nossos inimigos em pontos aleatório ao redor da borda da tela, para fazer isso, vamos traçar um caminho de onde podemos selecionar pontos aleatórios. Crie um nó do tipo `Path2D` nomeado `MobPath`, ao selecionar esse nó, um novo conjunto de botões vai aparecer no topo do editor.

<img width="827" height="71" alt="image" src="https://github.com/user-attachments/assets/363fcc1d-27c5-402d-94c9-c1cf9687493d" />

Selecione o botão "_Add point_", ative as opções "_Use grid snap_" e "_Use smart snap_", ambos são ícones com um imã, isso vai ajudar a marcar os pontos mais precisamente. Agora clique em cada um dos pontos da tela do seu jogo (o retângulo caso você não tenha percebido) e aperte o botão "_Close curve_". Agora adicione um nó do tipo `PathFollow2D` como filho de `MobPath` e nomeie-o `MobSpawnLocation`, um caminho de setas em sentido horário (isso é importante!) vai aparecer. E isso é tudo que precisamos, esse deve ser o produto final da sua cena.

<img width="300" height="400" alt="image" src="https://github.com/user-attachments/assets/1188702c-6d0e-4b50-ae27-a717da294530" />
<img width="300" height="400" alt="image" src="https://github.com/user-attachments/assets/3fd63114-6e3b-4894-b022-4b3ecf72efb1" />

> `Path2D`, uma curva (encapsula `Curve2D`) para um `PathFollow2D` seguir. `PathFollow2D` retorna as coordenadas de um ponto dentro do caminho de `Path2D` com base na distância do primeiro vértice. Permite criar caminhos sem programar padrões de movimento. Leia mais em [Path2D - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_path2d.html#class-path2d).

### Criando nosso scripts

Vamos programar nossa cena, abra novamente `main_game.rs` e adicione os seguintes campos a sua estrutura.
```rust
#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    mob_scene: OnReady<Gd<PackedScene>>,
    player: OnReady<Gd<Player>>,

    score: u32,
    base: Base<Node>
}
```
E atualize a função `init` para incluir esses novos campos.
```rust
fn init(base: Base<Self::Base>) -> Self {
    Self {
        mob_scene: OnReady::from_loaded("res://mob.tscn"),
        player: OnReady::from_node("Player"),
        score: 0,
        base
    } 
}
```

Adicionamos nossa pontuação (`score`), nosso `player` e `mob_scene` são para acessar nosso jogador e nossos inimigos de modo mais rápido, utilizamos `OnReady` para inicializar esses valores quando estiverem disponíveis. `PackedScene` nos permite escolher qual inimigo do conjunto spawnado queremos instanciar. Vamos criar duas funções, para iniciar o jogo e outra para encerrá-lo.

```rust

#[godot_api]
impl Main {
    // Nenhuma dessas funções será usada pelo Godot então não temos que adicionar o macro `#[func]`
    // encerra o jogo
    fn game_over(&mut self) {
        // TODO: parar o mob spawn
        // TODO: parar o incremento do score
    } 

    // começa um novo jogo
    fn new_game(&mut self) {
        // TODO: começar o mob spawn
        // TODO: começar o incremento do score
    }
}
```
Acessaremos os nós filhos da nossa cena com bastante frequência, então vamos criar funções utilitárias para nos ajudar com isso, ainda dentro do bloco `impl` escreveremos o seguinte código:
```rust
fn start_position(&self) -> Gd<Marker2D> {
    self.base().get_node_as::<Marker2D>("StartPosition")
}

fn score_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("ScoreTimer")
}

fn start_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("StartTimer")
}

fn mob_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("MobTimer")
}
```
Muito bem, agora podemos implementar as duas funções anteriores.

```rust
fn game_over(&mut self) {
    self.score_timer().stop();
    self.mob_timer().stop();
}

fn new_game(&mut self) {
    let start_pos = self.start_position().get_position();
    self.player.bind_mut().start(start_pos);
    
    self.start_timer().start();
}
```

Em `game_over`, paramos os temporizadores da pontuação e dos inimigos, já em `new_game`, pegamos o valor do nó `StartPosition` e inicializamos o jogador. Lembra da função `start` definida em `Player`? Estamos usando ela mesma, adicione a palavra-chave `pub` para torná-la visível a nossa cena. Também iniciamos o nó `StartTimer` para dar um delay antes da lógica do jogo começar e dar um tempo para o jogador se preparar. Vamos definir funções para quando os temporizadores encerrarem. Crie um funções para cada timer: `on_mob_timer_timeout`, `on_start_timer_timeout` e `on_score_timer_timeout`. Veja as implementações de cada uma.

```rust
#[func]
fn on_score_timer_timeout(&mut self) {
    self.score += 1;
}
```
Não tenho nem o que dizer sobre essa função.

```rust
#[func]
fn on_start_timer_timeout(&mut self) {
    self.score_timer().start();
    self.mob_timer().start();
}
```
Quando o temporizador acabar iniciamos o temporizador da pontuação e o temporizador de spawn de inimigos. ~~Estou falando muito temporizador.~~

```rust
#[func]
fn on_mob_timer_timeout(&mut self) {

    let mut mob_spawn_location = self.base().get_node_as::<PathFollow2D>("MobPath/MobSpawnLocation");
    let mut mob_scene = self.mob_scene.instantiate_as::<Mob>();

    let progress = rand::random_range(u32::MIN..u32::MAX) as f32;
    mob_spawn_location.set_progress(progress);
    mob_scene.set_position(mob_spawn_location.get_position());

    // apontamos o inimigo para o centro da tela
    let mut direction = mob_spawn_location.get_rotation() + std::f32::consts::PI / 2.0;
    // variamos a direção do movimento em 45º para + ou -
    direction += rand::random_range((-std::f32::consts::PI / 4.0)..std::f32::consts::PI/4.0);
    mob_scene.set_rotation(direction);

    // velocidade do inimigo é escolhida aleatoriamente
    let velocity = Vector2::new(rand::random_range(150..200) as f32, 0.0);
    mob_scene.set_linear_velocity(velocity.rotated(direction));

    self.base_mut().add_child(&mob_scene);
}
```
Essa função é a mais longa, primeiro criamos uma instância de `Mob`, pegamos uma posição aleatória de `MobSpawnLocation` e definimos como posição do inimigo. Depois pegamos a direção pré existente do caminho que estamos seguindo e viramos ela em $90º$ (para dentro da tela, se no sentindo horário), com uma certa aleatoriedade na direção. Por fim, escolhemos uma velocidade aleatória para o inimigo e adicionamos ele a cena principal. 

Concluindo essa parte, temos que conectar nossas funções aos sinais emitidos pelo Godot. Crie a função `ready` dentro do bloco `impl INode for Main`. Conecte o sinal de `timeout` dos temporizador com as funções de _timeout_, também conecte o sinal de `hit` do jogador com a função `game_over`. Para isso será preciso tornar a função `hit` pública.

```rust
fn ready(&mut self) {
    let game = self.to_gd();

    // se o jogador for atingido o jogo acaba
    self.player
        .signals()
        .hit()
        .connect_other(&game, Self::game_over);

    self.start_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_start_timer_timeout);

    self.mob_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_mob_timer_timeout);

    self.score_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_score_timer_timeout);
} 
```
Temos boa parte da lógica da cena feita, se quiser testar, chame `new_game` no final de `ready` e rode a cena principal, os inimigos vão _spawnar_ e se você encostar neles você morre!

## Criando a UI
Temos nosso jogo funcionando, mas precisamos de uma interface que informe o usuário sobre o status do jogo e o convide a jogar. Vamos criar uma _HUD_ (heads-up-display) uma interface que fica sobre a tela do jogo. 

No rust, crie um arquivo chamado `hud.rs` e declare-o na `lib.rs`. Esse nó será derivado de `CanvasLayer`, que é usado para desenhar objetos independentes na tela um nível acima do resto do jogo. Feito isso, crie uma nova cena utilizando esse nó como raiz, salve-a como `hud.tscn`, adicione os seguintes nós como filhos:

- um `Label` chamado `ScoreLabel`
- um `Label` chamado `Message`
- um `Button` chamado `StartButton`
- um `Timer` chamado `MessageTimer`

Vamos ajustar a fonte e o tamanho do texto nos _labels_ e no botão, em cada um dos três procure por `Control` > `Theme Overrides` no inspetor, em `Fonts` clique em `Load` e adicione a fonte guardada na pasta `fonts`, depois altere `Font Sizes` para `64px`. 

Todos esses componentes herdam de `Control` o que permite eles serem arranjados em **âncoras**, basicamente é um jeito de ajustar em posições fixas da tela. Ao selecionar qualquer um desses um novo conjunto de botões aparecerá na barra superior, faça uso dos _presets_ e ajuste de acordo.

<img width="293" height="331" alt="image" src="https://github.com/user-attachments/assets/aae2c09c-6f2d-4961-accb-01e438552c05" />

1. **ScoreLabel**: Adicione `0` ao campo de texto no inspetor, configure _Horizontal Alignment_ e _Vertical Alignment_ para `Center`, escolha o preset de âncora `Center Top`;
2. **Message**: Escreva `Dodge the Creeps!` na caixa de texto, configure o alinhamento do texto para `Center`, sete o atributo "Autowrap Mode" para `Word`, assim o texto quebrará de linha. Em `Control` > `Layout/Transform` sete `Size X` para `480`. Escolha o preset de âncora como `Center`; e
3. **StartButton**: Adicione o texto `Start`, em `Control`>`Layout/Transform` sete `Position Y` para `580`.

Por último, em `Message` configure `Wait Time` para `2` e `One Shot` para `On`. Não esqueça de instanciar sua cena HUD com a cena principal, assim como fizemos com Player.

<img width="390" height="562" alt="image" src="https://github.com/user-attachments/assets/0a53d79b-3c83-48d0-9854-6bbae29c5543" />

### Scripts da HUD

Vamos implementar as funcionalidades da nossa HUD, primeiro queremos que o jogo comece quando o botão for apertado, já vamos nos adiantar e criar um sinal para isso.
```rust
/// hud.rs
// ...
#[signal]
pub fn start_game();
```

Vamos criar funções para atualizar a pontuação, editar o conteúdo da mensagem e mostrar a tela de _game over_. Implementamos também as funções para acessar os nós filhos de forma mais rápida.

```rust
/// hud.rs
// ...
pub fn set_score(&mut self, score: u32) {
    self.score_label().set_text(score.to_string().as_str());
}

pub fn show_text(&mut self, text: &str) {
    let mut msg_label = self.message_label();
    msg_label.set_text(text);
    msg_label.show();

    self.message_timer().start();
}

fn message_label(&self) -> Gd<Label> {
    self.base().get_node_as("Message")
}

fn score_label(&self) -> Gd<Label> {
    self.base().get_node_as("ScoreLabel")
}

fn start_button(&self) -> Gd<Button> {
    self.base().get_node_as("StartButton")
}

fn message_timer(&self) -> Gd<Timer> {
    self.base().get_node_as("MessageTimer")
}
```

Nada muito interessante nessas funções para ser dito, exceto que queremos que a mensagem tenha um tempo temporizador isso vai ser útil para saber quando trocar mensagem, como no fim de jogo por exemplo.

Já para nossa função de gameover, queremos mostrar uma mensagem de "GameOver" e depois mostrar um botão convidando o usuário a reiniciar o jogo. Para isso, precisamos criar um temporizador de uso único com dois segundos de vida (tempo o bastante para mostrar a primeira mensagem), conectamos esse temporizador com uma função auxiliar `show_start_button`.
```rust
pub fn show_gameover(&mut self) {

    self.show_text("Game Over!");

    // criamos um timer de uso unico e esperamos ele acabar
    let timer = self.base().get_tree().unwrap().create_timer(2.0).unwrap();
    timer.signals()
        .timeout()
        .connect_other(self, Self::show_start_button);
}

fn show_start_button(&mut self) {
    let mut msg = self.message_label();
    msg.set_text("Dodge the Creeps!");
    msg.show();
    
    self.start_button().show();
}
```

> `create_timer` é uma ótima função caso você queira adicionar delays ou pausas sem introduzir nós extras na sua cena.

Não podemos nos esquecer das funcionalidades, queremos que quando o botão seja apertado o sinal de `start_game` seja emitido. Também queremos que a mensagem seja escondida depois que o temporizador encerrar.

```rust
// dentro de impl ICanvasLayer
fn ready(&mut self) {
    self.start_button()
        .signals()
        .pressed()
        .connect_other(self, Self::on_start_button_pressed);

    self.message_timer()
        .signals()
        .timeout()
        .connect_other(self, Self::on_message_timer_timeout);
}

// dentro de impl HUD
#[func]
fn on_start_button_pressed(&mut self) {
    self.start_button().hide();
    self.signals().start_game().emit();
}

#[func]
fn on_message_timer_timeout(&mut self) {
    self.message_label().hide();
}
```

Agora precisamos conectar nossa HUD com a cena principal, vá para `main_game.rs`, adicione `Hud` a nossa estrutura da mesma forma que Player. Não esqueça de adicionar `hud: OnReady::from_node("HUD")` no construtor. 

```rust
#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    mob_scene: OnReady<Gd<PackedScene>>,
    player: OnReady<Gd<Player>>,
    hud: OnReady<Gd<HUD>>,

    score: u32,
    base: Base<Node>
}
```

Vamos iniciar o jogo quando o sinal `start_game` for emitido, adicione essas linhas no final da função `ready`.
```rust
self.hud
    .signals()
    .start_game()
    .connect_other(&game, Self::new_game);
```

Em `game_over` adicione a seguinte linha para mostrar a mensagem de fim de jogo.
```rust
self.hud.bind_mut().show_gameover();
```
Por fim, edite `new_game` e `on_score_timer_timeout` para atualizar a pontuação do jogo.
```rust
// new_game
//...
self.hud.bind_mut().set_score(self.score);
self.hud.bind_mut().show_text("Get Ready");
```
```rust
// on_score_timer_timeout
self.hud.bind_mut().set_score(self.score);
```

Rode o jogo e você verá que ele está funcionando!

### Removendo inimigos

Ao reiniciar o jogo você verá que os inimigos permanencem na tela entre jogadas, precisamos deletá-los sempre que o jogo reiniciar, podemos fazer isso de um jeito bem fácil com **grupos**, ou seja podemos categorizar nossos inimigos sendo do mesmo grupo e aplicar uma função sobre eles. Vá para a `mob.tcsn`, selecione o nó raiz e vá para a aba `Node` (a mesma do inspetor) e clique em "Groups", adicione um novo grupo chamado `mobs`.

<img width="290" height="238" alt="image" src="https://github.com/user-attachments/assets/26616346-49a0-4f77-960b-60b3581e468d" />

Agora todos os inimigos pertencem ao grupo mobs. De volta ao Rust, na função `new_game` adicione a seguinte linha. Ela vai chamar a função `queue_free` para todos os elementos no grupo "mobs".
```rust
self.base().get_tree().unwrap().call_group("mobs", "queue_free", &[]);
```

Com nosso jogo funcionando podemos adicionar alguns toques cosméticos, como cores e música, vamos encerrar esse jogo com chave de ouro.

## Toques finais



