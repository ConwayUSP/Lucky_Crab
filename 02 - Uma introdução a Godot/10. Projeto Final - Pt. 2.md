# 10. Projeto Final - Parte 2

Olá, bem-vindo de volta! No último capítulo você configurou o projeto final e criou as entidades jogador e inimigo, agora nós vamos juntar as cenas e criar a lógica principal do nosso jogo. Preparado? Espero que sim!

## Cena Principal

Vamos criar nossa cena principal, crie um arquivo chamado `main_game.rs` e declare o módulo em `lib.rs`. Insira o _boilerplate_ no arquivo recém criado, nosso nó irá herdar de `Node`.

```rust
/// main_game.rs
use godot::prelude::*;
use godot::classes::Node;

#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    base: Base<Node>
}

#[godot_api]
impl INode for Main {
    fn init(base: Base<Self::Base>) -> Self {
        Self {
            base,
        }
    }
}
```

Compile a biblioteca novamente, e crie uma nova cena no Godot, o nó raiz deve ser `Main`. Crie uma **instância** apertando o botão em formato de corrente e selecione `player.tscn`. Desse modo, alterações na cena do jogador serão expostas na cena principal. Agora adicione os seguintes nós como filhos da `Main`:

- `Timer` nomeado como `MobTimer`, para controlar o tempo que os inimigos vão spawnat
- `Timer` nomeado como `ScoreTimer`, para incrementar a pontuação do jogo
- `Timer` nomeado como `StartTimer`, para dar um delay nos spawns antes do jogo começar
- `Marker2D` nomeado como `StartPosition` indicando onde o jogador vai spawnar

Em cada temporizador, configure a propriedade `WaitTime` do seguinte modo:

- `MobTimer`: $0.5$
- `ScoreTimer`: $1$
- `StartTimer`: $2$

Além disso, `StartTime` deve ter a propriedade `OneShot` ativada, e `StartPosition` deve ter `Position` setado para `(240, 450)`.

> `Timer` é um nó **temporizador**, uma vez completado seu `wait_time` (tempo de espera) ele emite um sinal de `timeout`, podendo ser reiniciado com a função `start`, leia mais em [Timer - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_timer.html#class-timer).

> `Marker2D` representa uma posição em um plano 2D, é apenas um encapsulamento de `Node2D` mas ele mostra uma marcação ~~duh~~ no editor do Godot, leia mais em [Marker2D - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_marker2d.html#class-marker2d).

### Spawnar inimigos

Queremos spawnar nossos inimigos em pontos aleatório ao redor da borda da tela, para fazer isso, vamos traçar um caminho de onde podemos selecionar pontos aleatórios. Crie um nó do tipo `Path2D` nomeado `MobPath`, ao selecionar esse nó, um novo conjunto de botões vai aparecer no topo do editor.

<img width="827" height="71" alt="image" src="https://github.com/user-attachments/assets/363fcc1d-27c5-402d-94c9-c1cf9687493d" />

Selecione o botão "_Add point_", ative as opções "_Use grid snap_" e "_Use smart snap_", ambos são ícones com um imã, isso vai ajudar a marcar os pontos mais precisamente. Agora clique em cada um dos pontos da tela do seu jogo (o retângulo caso você não tenha percebido) e aperte o botão "_Close curve_". Agora adicione um nó do tipo `PathFollow2D` como filho de `MobPath` e nomeie-o `MobSpawnLocation`, um caminho de setas em sentido horário (isso é importante!) vai aparecer. E isso é tudo que precisamos, esse deve ser o produto final da sua cena.

<img width="300" height="400" alt="image" src="https://github.com/user-attachments/assets/1188702c-6d0e-4b50-ae27-a717da294530" />
<img width="300" height="400" alt="image" src="https://github.com/user-attachments/assets/3fd63114-6e3b-4894-b022-4b3ecf72efb1" />

> `Path2D`, uma curva (encapsula `Curve2D`) para um `PathFollow2D` seguir. `PathFollow2D` retorna as coordenadas de um ponto dentro do caminho de `Path2D` com base na distância do primeiro vértice. Permite criar caminhos sem programar padrões de movimento. Leia mais em [Path2D - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_path2d.html#class-path2d).

### Criando nosso scripts

Vamos programar nossa cena, abra novamente `main_game.rs` e adicione os seguintes campos a sua estrutura.
```rust
#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    mob_scene: OnReady<Gd<PackedScene>>,
    player: OnReady<Gd<Player>>,

    score: u32,
    base: Base<Node>
}
```
E atualize a função `init` para incluir esses novos campos.
```rust
fn init(base: Base<Self::Base>) -> Self {
    Self {
        mob_scene: OnReady::from_loaded("res://mob.tscn"),
        player: OnReady::from_node("Player"),
        score: 0,
        base
    } 
}
```

Adicionamos nossa pontuação (`score`), nosso `player` e `mob_scene` são para acessar nosso jogador e nossos inimigos de modo mais rápido, utilizamos `OnReady` para inicializar esses valores quando estiverem disponíveis. `PackedScene` nos permite escolher qual inimigo do conjunto spawnado queremos instanciar. Vamos criar duas funções, para iniciar o jogo e outra para encerrá-lo.

```rust

#[godot_api]
impl Main {
    // Nenhuma dessas funções será usada pelo Godot então não temos que adicionar o macro `#[func]`
    // encerra o jogo
    fn game_over(&mut self) {
        // TODO: parar o mob spawn
        // TODO: parar o incremento do score
    } 

    // começa um novo jogo
    fn new_game(&mut self) {
        // TODO: começar o mob spawn
        // TODO: começar o incremento do score
    }
}
```
Acessaremos os nós filhos da nossa cena com bastante frequência, então vamos criar funções utilitárias para nos ajudar com isso, ainda dentro do bloco `impl` escreveremos o seguinte código:
```rust
fn start_position(&self) -> Gd<Marker2D> {
    self.base().get_node_as::<Marker2D>("StartPosition")
}

fn score_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("ScoreTimer")
}

fn start_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("StartTimer")
}

fn mob_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("MobTimer")
}
```
Muito bem, agora podemos implementar as duas funções anteriores.

```rust
fn game_over(&mut self) {
    self.score_timer().stop();
    self.mob_timer().stop();
}

fn new_game(&mut self) {
    let start_pos = self.start_position().get_position();
    self.player.bind_mut().start(start_pos);
    
    self.start_timer().start();
}
```

Em `game_over`, paramos os temporizadores da pontuação e dos inimigos, já em `new_game`, pegamos o valor do nó `StartPosition` e inicializamos o jogador. Lembra da função `start` definida em `Player`? Estamos usando ela mesma, adicione a palavra-chave `pub` para torná-la visível a nossa cena. Também iniciamos o nó `StartTimer` para dar um delay antes da lógica do jogo começar e dar um tempo para o jogador se preparar. Vamos definir funções para quando os temporizadores encerrarem. Crie um funções para cada timer: `on_mob_timer_timeout`, `on_start_timer_timeout` e `on_score_timer_timeout`. Veja as implementações de cada uma.

```rust
#[func]
fn on_score_timer_timeout(&mut self) {
    self.score += 1;
}
```
Não tenho nem o que dizer sobre essa função.

```rust
#[func]
fn on_start_timer_timeout(&mut self) {
    self.score_timer().start();
    self.mob_timer().start();
}
```
Quando o temporizador acabar iniciamos o temporizador da pontuação e o temporizador de spawn de inimigos. ~~Estou falando muito temporizador.~~

```rust
#[func]
fn on_mob_timer_timeout(&mut self) {

    let mut mob_spawn_location = self.base().get_node_as::<PathFollow2D>("MobPath/MobSpawnLocation");
    let mut mob_scene = self.mob_scene.instantiate_as::<Mob>();

    let progress = rand::random_range(u32::MIN..u32::MAX) as f32;
    mob_spawn_location.set_progress(progress);
    mob_scene.set_position(mob_spawn_location.get_position());

    // apontamos o inimigo para o centro da tela
    let mut direction = mob_spawn_location.get_rotation() + std::f32::consts::PI / 2.0;
    // variamos a direção do movimento em 45º para + ou -
    direction += rand::random_range((-std::f32::consts::PI / 4.0)..std::f32::consts::PI/4.0);
    mob_scene.set_rotation(direction);

    // velocidade do inimigo é escolhida aleatoriamente
    let velocity = Vector2::new(rand::random_range(150..200) as f32, 0.0);
    mob_scene.set_linear_velocity(velocity.rotated(direction));

    self.base_mut().add_child(&mob_scene);
}
```
Essa função é a mais longa, primeiro criamos uma instância de `Mob`, pegamos uma posição aleatória de `MobSpawnLocation` e definimos como posição do inimigo. Depois pegamos a direção pré existente do caminho que estamos seguindo e viramos ela em $90º$ (para dentro da tela, se no sentindo horário), com uma certa aleatoriedade na direção. Por fim, escolhemos uma velocidade aleatória para o inimigo e adicionamos ele a cena principal. 

Concluindo essa parte, temos que conectar nossas funções aos sinais emitidos pelo Godot. Crie a função `ready` dentro do bloco `impl INode for Main`. Conecte o sinal de `timeout` dos temporizador com as funções de _timeout_, também conecte o sinal de `hit` do jogador com a função `game_over`. Para isso será preciso tornar a função `hit` pública.

```rust
fn ready(&mut self) {
    let game = self.to_gd();

    // se o jogador for atingido o jogo acaba
    self.player
        .signals()
        .hit()
        .connect_other(&game, Self::game_over);

    self.start_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_start_timer_timeout);

    self.mob_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_mob_timer_timeout);

    self.score_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_score_timer_timeout);
} 
```
Temos boa parte da lógica da cena feita, se quiser testar, chame `new_game` no final de `ready` e rode a cena principal, os inimigos vão _spawnar_ e se você encostar neles você morre!

## Criando a UI
Temos nosso jogo funcionando, mas precisamos de uma interface que informe o usuário sobre o status do jogo e o convide a jogar. Vamos criar uma _HUD_ (heads-up-display) uma interface que fica sobre a tela do jogo. 

No rust, crie um arquivo chamado `hud.rs` e declare-o na `lib.rs`. Esse nó será derivado de `CanvasLayer`, que é usado para desenhar objetos independentes na tela um nível acima do resto do jogo. Feito isso, crie uma nova cena utilizando esse nó como raiz, salve-a como `hud.tscn`, adicione os seguintes nós como filhos:

- um `Label` chamado `ScoreLabel`
- um `Label` chamado `Message`
- um `Button` chamado `StartButton`
- um `Timer` chamado `MessageTimer`

Vamos ajustar a fonte e o tamanho do texto nos _labels_ e no botão, em cada um dos três procure por `Control` > `Theme Overrides` no inspetor, em `Fonts` clique em `Load` e adicione a fonte guardada na pasta `fonts`, depois altere `Font Sizes` para `64px`. 

Todos esses componentes herdam de `Control` o que permite eles serem arranjados em **âncoras**, basicamente é um jeito de ajustar em posições fixas da tela. Ao selecionar qualquer um desses um novo conjunto de botões aparecerá na barra superior, faça uso dos _presets_ e ajuste de acordo.

<img width="293" height="331" alt="image" src="https://github.com/user-attachments/assets/aae2c09c-6f2d-4961-accb-01e438552c05" />

1. **ScoreLabel**: Adicione `0` ao campo de texto no inspetor, configure _Horizontal Alignment_ e _Vertical Alignment_ para `Center`, escolha o preset de âncora `Center Top`;
2. **Message**: Escreva `Dodge the Creeps!` na caixa de texto, configure o alinhamento do texto para `Center`, sete o atributo "Autowrap Mode" para `Word`, assim o texto quebrará de linha. Em `Control` > `Layout/Transform` sete `Size X` para `480`. Escolha o preset de âncora como `Center`; e
3. **StartButton**: Adicione o texto `Start`, em `Control`>`Layout/Transform` sete `Position Y` para `580`.

Por último, em `Message` configure `Wait Time` para `2` e `One Shot` para `On`. Não esqueça de instanciar sua cena HUD com a cena principal, assim como fizemos com Player.

<img width="390" height="562" alt="image" src="https://github.com/user-attachments/assets/0a53d79b-3c83-48d0-9854-6bbae29c5543" />

### Scripts da HUD

Vamos implementar as funcionalidades da nossa HUD, primeiro queremos que o jogo comece quando o botão for apertado, já vamos nos adiantar e criar um sinal para isso.
```rust
/// hud.rs
// ...
#[signal]
pub fn start_game();
```

Vamos criar funções para atualizar a pontuação, editar o conteúdo da mensagem e mostrar a tela de _game over_. Implementamos também as funções para acessar os nós filhos de forma mais rápida.

```rust
/// hud.rs
// ...
pub fn set_score(&mut self, score: u32) {
    self.score_label().set_text(score.to_string().as_str());
}

pub fn show_text(&mut self, text: &str) {
    let mut msg_label = self.message_label();
    msg_label.set_text(text);
    msg_label.show();

    self.message_timer().start();
}

fn message_label(&self) -> Gd<Label> {
    self.base().get_node_as("Message")
}

fn score_label(&self) -> Gd<Label> {
    self.base().get_node_as("ScoreLabel")
}

fn start_button(&self) -> Gd<Button> {
    self.base().get_node_as("StartButton")
}

fn message_timer(&self) -> Gd<Timer> {
    self.base().get_node_as("MessageTimer")
}
```

Nada muito interessante nessas funções para ser dito, exceto que queremos que a mensagem tenha um tempo temporizador isso vai ser útil para saber quando trocar mensagem, como no fim de jogo por exemplo.

Já para nossa função de gameover, queremos mostrar uma mensagem de "GameOver" e depois mostrar um botão convidando o usuário a reiniciar o jogo. Para isso, precisamos criar um temporizador de uso único com dois segundos de vida (tempo o bastante para mostrar a primeira mensagem), conectamos esse temporizador com uma função auxiliar `show_start_button`.
```rust
pub fn show_gameover(&mut self) {

    self.show_text("Game Over!");

    // criamos um timer de uso unico e esperamos ele acabar
    let timer = self.base().get_tree().unwrap().create_timer(2.0).unwrap();
    timer.signals()
        .timeout()
        .connect_other(self, Self::show_start_button);
}

fn show_start_button(&mut self) {
    let mut msg = self.message_label();
    msg.set_text("Dodge the Creeps!");
    msg.show();
    
    self.start_button().show();
}
```

> `create_timer` é uma ótima função caso você queira adicionar delays ou pausas sem introduzir nós extras na sua cena.

Não podemos nos esquecer das funcionalidades, queremos que quando o botão seja apertado o sinal de `start_game` seja emitido. Também queremos que a mensagem seja escondida depois que o temporizador encerrar.

```rust
// dentro de impl ICanvasLayer
fn ready(&mut self) {
    self.start_button()
        .signals()
        .pressed()
        .connect_other(self, Self::on_start_button_pressed);

    self.message_timer()
        .signals()
        .timeout()
        .connect_other(self, Self::on_message_timer_timeout);
}

// dentro de impl HUD
#[func]
fn on_start_button_pressed(&mut self) {
    self.start_button().hide();
    self.signals().start_game().emit();
}

#[func]
fn on_message_timer_timeout(&mut self) {
    self.message_label().hide();
}
```

Agora precisamos conectar nossa HUD com a cena principal, vá para `main_game.rs`, adicione `Hud` a nossa estrutura da mesma forma que Player. Não esqueça de adicionar `hud: OnReady::from_node("HUD")` no construtor. 

```rust
#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    mob_scene: OnReady<Gd<PackedScene>>,
    player: OnReady<Gd<Player>>,
    hud: OnReady<Gd<HUD>>,

    score: u32,
    base: Base<Node>
}
```

Vamos iniciar o jogo quando o sinal `start_game` for emitido, adicione essas linhas no final da função `ready`.
```rust
self.hud
    .signals()
    .start_game()
    .connect_other(&game, Self::new_game);
```

Em `game_over` adicione a seguinte linha para mostrar a mensagem de fim de jogo.
```rust
self.hud.bind_mut().show_gameover();
```
Por fim, edite `new_game` e `on_score_timer_timeout` para atualizar a pontuação do jogo.
```rust
// new_game
//...
self.hud.bind_mut().set_score(self.score);
self.hud.bind_mut().show_text("Get Ready");
```
```rust
// on_score_timer_timeout
self.hud.bind_mut().set_score(self.score);
```

Rode o jogo e você verá que ele está funcionando!

### Removendo inimigos

Ao reiniciar o jogo você verá que os inimigos permanencem na tela entre jogadas, precisamos deletá-los sempre que o jogo reiniciar, podemos fazer isso de um jeito bem fácil com **grupos**, ou seja podemos categorizar nossos inimigos sendo do mesmo grupo e aplicar uma função sobre eles. Vá para a `mob.tcsn`, selecione o nó raiz e vá para a aba `Node` (a mesma do inspetor) e clique em "Groups", adicione um novo grupo chamado `mobs`.

<img width="290" height="238" alt="image" src="https://github.com/user-attachments/assets/26616346-49a0-4f77-960b-60b3581e468d" />

Agora todos os inimigos pertencem ao grupo mobs. De volta ao Rust, na função `new_game` adicione a seguinte linha. Ela vai chamar a função `queue_free` para todos os elementos no grupo "mobs".
```rust
self.base().get_tree().unwrap().call_group("mobs", "queue_free", &[]);
```


## Toques finais

Com nosso jogo funcionando podemos adicionar alguns toques cosméticos, como cores e música, vamos encerrar esse jogo com chave de ouro.

Hora de tirar esse fundo cinza genérico e dar um toque de elegância, crie um nó do tipo `ColorRect` e faça ele ser o primeiro nó abaixo da `Main`, assim ele estará no fundo da tela. Ajuste a única propriedade, `Color`, para a cor que você quiser e em `Layout` > `Anchors Preset` ajuste para `Full Rect`. Agora temos um plano de fundo , com uma cor mais interessante. Você pode botar uma imagem usando o nó `TextureRect`, leia mais [aqui](https://docs.godotengine.org/en/stable/classes/class_texturerect.html#class-texturerect).

### Efeitos sonoros

Poucas coisas são mais legais que músicas de videogame, felizmente nossos assets contém duas _soundtracks_ para tocarmos, uma vai rodar durante o jogo todo, outra é um som para quando o jogador morrer. Adicione dois nós do tipo `AudioStreamPlayer` à `Main`. Chame uma de `Music` outra `DeathSound`. Para cada uma, acesse a propriedade de `Stream`, clique em `Load`, escolha o áudio correspondente da pasta `art`. Para fazer o áudio tocar em _loop_, clique na seta de Stream, selecione `Make Unique`, e clique no arquivo de Stream, então selecione a opção `Loop`.

<img width="387" height="335" alt="image" src="https://github.com/user-attachments/assets/cc442388-a5c9-4572-8330-898e263b446c" />

Para o código, crie uma função `music` e `deathsound` para acessar os nós, inicie a música com `self.music().play()` em `new_game`, pare-a em `game_over` e toque deathsound.

```rust
fn new_game() {
    ...
    self.music().play();
}

fn game_over() {
    ...
    self.music().stop();
    self.deathsound().play();
}
``` 

### Shortcuts

Seria bem conveniente poder apertar uma tecla para começar o jogo não é? ~~Não!? fds faz parte da aula.~~ Isso é possível por meio de um atalho ligado ao nó `Button`, veja como fazer isso.

Em `Project` > `Project Settings` > `Input Map`, crie uma ação chamada `start`, atrele uma tecla a ela, no meu caso será `Space` a tecla de espaço. Na `HUD`, selecione `StartButton` e vá para a inspeção, dentro da propriedade **Shortcut**, acesse **Events**, clique para adicionar um novo elemento, clique em **Array[InputEvent](size 0)** e selecione **InputEventAction**, nomeie como `start`. 

> Se você tiver um controle de vídeo game também pode adicionar como shortcut!

<img width="410" height="461" alt="image" src="https://github.com/user-attachments/assets/68101180-2c23-436f-97cd-2ba26dc1119f" />

É só isso, está feito, você completou seu jogo, meus parabéns🥇!

### Exportando o Jogo

Não adianta nada criar o jogo mais incrível de todos se você não puder compartilhá-lo. Vamos exportar nosso jogo para um executável. Antes de tudo, compile a biblioteca do Rust para a versão de _release_, ou seja, alguns elementos de debug serão retirados e otimizações serão feitas.
```sh
cargo build --release
```

Abra a opção _Editor_ > _Manage Export Templates_, e baixe a versão mais recente para exportar seu projeto. A instalação pode demorar um pouco mas é com ele que o Godot vai criar o seu executável.

<img width="740" height="402" alt="image" src="https://github.com/user-attachments/assets/1f6acf78-2cab-4da9-b493-cbccf8aba100" />

Agora vá para _Project_ > _Export..._, clique em _Add_ e escolha o seus sistema operacional e clique em `Export Project`, clique em Ok, escolha um nome e confirme.

<img width="920" height="605" alt="image" src="https://github.com/user-attachments/assets/4569ce57-8328-43df-b8bb-16a154c76086" />

Protinho! Alguns arquivos e um executável serão criados para você dentro da pasta do seu projeto. Pegue o executável, o arquivo `.so` (a biblioteca criada por nós, copiada para a pasta godot) e um arquivo `.pck`, compacte-os em um ZIP e compartilhe com seus amigos, família ou interesse amoroso.

## Continuando sua jornada

Nossa! Você chegou longe, essa foi uma longa jornada. Espero muito que você tenha aprendido algo sobre desenvolvimento de jogos e Rust e que tenha gostado desse tutorial. Caso tenha tido dúvidas, queira nos dar sugestões ou bater papo abra uma issue ou mande uma mensagem, ficaremos felizes com isso.

Você pode estar se perguntando "o que eu faço com a minha vida agora?", essa é uma resposta que eu não tenho. Mas se quiser continuar aprendendo aqui vai algumas sugestões:

- Brinque com o que você já fez, mude as cores de fundo, adicione powerups ou salve o estado do jogo em um arquivo;
- Faça projetos parecidos, o [Tutorial Oficial tem um jogo 3D](https://docs.godotengine.org/en/stable/getting_started/first_3d_game/index.html), experimente fazê-lo!
- Leia o manual do Godot para saber mais sobre os nós disponíveis e o que eles fazem, mal tocamos a superfície nesse curso;
- Aprenda mais sobre desenvolvimento de jogos com Godot, como boas práticas e padrões de projeto;
- Veja como utilizar mais as funcionalidades do Rust, como enums, multi-threading, etc;
- Compartilhe o que você está fazendo e procure pessoas que possam de ajudar e incentivar; e
- Divirta-se e relaxe! Não tente fazer o próximo GTA6, comece por jogos simples, tente criar sistemas isolados e reutilizáveis tipo inventário ou animação de personagens.

Por hoje é só isso, espero que tenha gostado dessa jornada, torço para que continue nessa estrada. Até a próxima!
