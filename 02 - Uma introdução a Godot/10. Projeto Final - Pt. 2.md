# 10. Projeto Final - Parte 2

Ol√°, bem-vindo de volta! No √∫ltimo cap√≠tulo voc√™ configurou o projeto final e criou as entidades jogador e inimigo, agora n√≥s vamos juntar as cenas e criar a l√≥gica principal do nosso jogo. Preparado? Espero que sim!

## Cena Principal

Vamos criar nossa cena principal, crie um arquivo chamado `main_game.rs` e declare o m√≥dulo em `lib.rs`. Insira o _boilerplate_ no arquivo rec√©m criado, nosso n√≥ ir√° herdar de `Node`.

```rust
/// main_game.rs
use godot::prelude::*;
use godot::classes::Node;

#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    base: Base<Node>
}

#[godot_api]
impl INode for Main {
    fn init(base: Base<Self::Base>) -> Self {
        Self {
            base,
        }
    }
}
```

Compile a biblioteca novamente, e crie uma nova cena no Godot, o n√≥ raiz deve ser `Main`. Crie uma **inst√¢ncia** apertando o bot√£o em formato de corrente e selecione `player.tscn`. Desse modo, altera√ß√µes na cena do jogador ser√£o expostas na cena principal. Agora adicione os seguintes n√≥s como filhos da `Main`:

- `Timer` nomeado como `MobTimer`, para controlar o tempo que os inimigos v√£o spawnat
- `Timer` nomeado como `ScoreTimer`, para incrementar a pontua√ß√£o do jogo
- `Timer` nomeado como `StartTimer`, para dar um delay nos spawns antes do jogo come√ßar
- `Marker2D` nomeado como `StartPosition` indicando onde o jogador vai spawnar

Em cada temporizador, configure a propriedade `WaitTime` do seguinte modo:

- `MobTimer`: $0.5$
- `ScoreTimer`: $1$
- `StartTimer`: $2$

Al√©m disso, `StartTime` deve ter a propriedade `OneShot` ativada, e `StartPosition` deve ter `Position` setado para `(240, 450)`.

> `Timer` √© um n√≥ **temporizador**, uma vez completado seu `wait_time` (tempo de espera) ele emite um sinal de `timeout`, podendo ser reiniciado com a fun√ß√£o `start`, leia mais em [Timer - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_timer.html#class-timer).

> `Marker2D` representa uma posi√ß√£o em um plano 2D, √© apenas um encapsulamento de `Node2D` mas ele mostra uma marca√ß√£o ~~duh~~ no editor do Godot, leia mais em [Marker2D - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_marker2d.html#class-marker2d).

### Spawnar inimigos

Queremos spawnar nossos inimigos em pontos aleat√≥rio ao redor da borda da tela, para fazer isso, vamos tra√ßar um caminho de onde podemos selecionar pontos aleat√≥rios. Crie um n√≥ do tipo `Path2D` nomeado `MobPath`, ao selecionar esse n√≥, um novo conjunto de bot√µes vai aparecer no topo do editor.

<img width="827" height="71" alt="image" src="https://github.com/user-attachments/assets/363fcc1d-27c5-402d-94c9-c1cf9687493d" />

Selecione o bot√£o "_Add point_", ative as op√ß√µes "_Use grid snap_" e "_Use smart snap_", ambos s√£o √≠cones com um im√£, isso vai ajudar a marcar os pontos mais precisamente. Agora clique em cada um dos pontos da tela do seu jogo (o ret√¢ngulo caso voc√™ n√£o tenha percebido) e aperte o bot√£o "_Close curve_". Agora adicione um n√≥ do tipo `PathFollow2D` como filho de `MobPath` e nomeie-o `MobSpawnLocation`, um caminho de setas em sentido hor√°rio (isso √© importante!) vai aparecer. E isso √© tudo que precisamos, esse deve ser o produto final da sua cena.

<img width="300" height="400" alt="image" src="https://github.com/user-attachments/assets/1188702c-6d0e-4b50-ae27-a717da294530" />
<img width="300" height="400" alt="image" src="https://github.com/user-attachments/assets/3fd63114-6e3b-4894-b022-4b3ecf72efb1" />

> `Path2D`, uma curva (encapsula `Curve2D`) para um `PathFollow2D` seguir. `PathFollow2D` retorna as coordenadas de um ponto dentro do caminho de `Path2D` com base na dist√¢ncia do primeiro v√©rtice. Permite criar caminhos sem programar padr√µes de movimento. Leia mais em [Path2D - Godot Manual](https://docs.godotengine.org/en/stable/classes/class_path2d.html#class-path2d).

### Criando nosso scripts

Vamos programar nossa cena, abra novamente `main_game.rs` e adicione os seguintes campos a sua estrutura.
```rust
#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    mob_scene: OnReady<Gd<PackedScene>>,
    player: OnReady<Gd<Player>>,

    score: u32,
    base: Base<Node>
}
```
E atualize a fun√ß√£o `init` para incluir esses novos campos.
```rust
fn init(base: Base<Self::Base>) -> Self {
    Self {
        mob_scene: OnReady::from_loaded("res://mob.tscn"),
        player: OnReady::from_node("Player"),
        score: 0,
        base
    } 
}
```

Adicionamos nossa pontua√ß√£o (`score`), nosso `player` e `mob_scene` s√£o para acessar nosso jogador e nossos inimigos de modo mais r√°pido, utilizamos `OnReady` para inicializar esses valores quando estiverem dispon√≠veis. `PackedScene` nos permite escolher qual inimigo do conjunto spawnado queremos instanciar. Vamos criar duas fun√ß√µes, para iniciar o jogo e outra para encerr√°-lo.

```rust

#[godot_api]
impl Main {
    // Nenhuma dessas fun√ß√µes ser√° usada pelo Godot ent√£o n√£o temos que adicionar o macro `#[func]`
    // encerra o jogo
    fn game_over(&mut self) {
        // TODO: parar o mob spawn
        // TODO: parar o incremento do score
    } 

    // come√ßa um novo jogo
    fn new_game(&mut self) {
        // TODO: come√ßar o mob spawn
        // TODO: come√ßar o incremento do score
    }
}
```
Acessaremos os n√≥s filhos da nossa cena com bastante frequ√™ncia, ent√£o vamos criar fun√ß√µes utilit√°rias para nos ajudar com isso, ainda dentro do bloco `impl` escreveremos o seguinte c√≥digo:
```rust
fn start_position(&self) -> Gd<Marker2D> {
    self.base().get_node_as::<Marker2D>("StartPosition")
}

fn score_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("ScoreTimer")
}

fn start_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("StartTimer")
}

fn mob_timer(&self) -> Gd<Timer> {
    self.base().get_node_as::<Timer>("MobTimer")
}
```
Muito bem, agora podemos implementar as duas fun√ß√µes anteriores.

```rust
fn game_over(&mut self) {
    self.score_timer().stop();
    self.mob_timer().stop();
}

fn new_game(&mut self) {
    let start_pos = self.start_position().get_position();
    self.player.bind_mut().start(start_pos);
    
    self.start_timer().start();
}
```

Em `game_over`, paramos os temporizadores da pontua√ß√£o e dos inimigos, j√° em `new_game`, pegamos o valor do n√≥ `StartPosition` e inicializamos o jogador. Lembra da fun√ß√£o `start` definida em `Player`? Estamos usando ela mesma, adicione a palavra-chave `pub` para torn√°-la vis√≠vel a nossa cena. Tamb√©m iniciamos o n√≥ `StartTimer` para dar um delay antes da l√≥gica do jogo come√ßar e dar um tempo para o jogador se preparar. Vamos definir fun√ß√µes para quando os temporizadores encerrarem. Crie um fun√ß√µes para cada timer: `on_mob_timer_timeout`, `on_start_timer_timeout` e `on_score_timer_timeout`. Veja as implementa√ß√µes de cada uma.

```rust
#[func]
fn on_score_timer_timeout(&mut self) {
    self.score += 1;
}
```
N√£o tenho nem o que dizer sobre essa fun√ß√£o.

```rust
#[func]
fn on_start_timer_timeout(&mut self) {
    self.score_timer().start();
    self.mob_timer().start();
}
```
Quando o temporizador acabar iniciamos o temporizador da pontua√ß√£o e o temporizador de spawn de inimigos. ~~Estou falando muito temporizador.~~

```rust
#[func]
fn on_mob_timer_timeout(&mut self) {

    let mut mob_spawn_location = self.base().get_node_as::<PathFollow2D>("MobPath/MobSpawnLocation");
    let mut mob_scene = self.mob_scene.instantiate_as::<Mob>();

    let progress = rand::random_range(u32::MIN..u32::MAX) as f32;
    mob_spawn_location.set_progress(progress);
    mob_scene.set_position(mob_spawn_location.get_position());

    // apontamos o inimigo para o centro da tela
    let mut direction = mob_spawn_location.get_rotation() + std::f32::consts::PI / 2.0;
    // variamos a dire√ß√£o do movimento em 45¬∫ para + ou -
    direction += rand::random_range((-std::f32::consts::PI / 4.0)..std::f32::consts::PI/4.0);
    mob_scene.set_rotation(direction);

    // velocidade do inimigo √© escolhida aleatoriamente
    let velocity = Vector2::new(rand::random_range(150..200) as f32, 0.0);
    mob_scene.set_linear_velocity(velocity.rotated(direction));

    self.base_mut().add_child(&mob_scene);
}
```
Essa fun√ß√£o √© a mais longa, primeiro criamos uma inst√¢ncia de `Mob`, pegamos uma posi√ß√£o aleat√≥ria de `MobSpawnLocation` e definimos como posi√ß√£o do inimigo. Depois pegamos a dire√ß√£o pr√© existente do caminho que estamos seguindo e viramos ela em $90¬∫$ (para dentro da tela, se no sentindo hor√°rio), com uma certa aleatoriedade na dire√ß√£o. Por fim, escolhemos uma velocidade aleat√≥ria para o inimigo e adicionamos ele a cena principal. 

Concluindo essa parte, temos que conectar nossas fun√ß√µes aos sinais emitidos pelo Godot. Crie a fun√ß√£o `ready` dentro do bloco `impl INode for Main`. Conecte o sinal de `timeout` dos temporizador com as fun√ß√µes de _timeout_, tamb√©m conecte o sinal de `hit` do jogador com a fun√ß√£o `game_over`. Para isso ser√° preciso tornar a fun√ß√£o `hit` p√∫blica.

```rust
fn ready(&mut self) {
    let game = self.to_gd();

    // se o jogador for atingido o jogo acaba
    self.player
        .signals()
        .hit()
        .connect_other(&game, Self::game_over);

    self.start_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_start_timer_timeout);

    self.mob_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_mob_timer_timeout);

    self.score_timer()
        .signals()
        .timeout()
        .connect_other(&game, Self::on_score_timer_timeout);
} 
```
Temos boa parte da l√≥gica da cena feita, se quiser testar, chame `new_game` no final de `ready` e rode a cena principal, os inimigos v√£o _spawnar_ e se voc√™ encostar neles voc√™ morre!

## Criando a UI
Temos nosso jogo funcionando, mas precisamos de uma interface que informe o usu√°rio sobre o status do jogo e o convide a jogar. Vamos criar uma _HUD_ (heads-up-display) uma interface que fica sobre a tela do jogo. 

No rust, crie um arquivo chamado `hud.rs` e declare-o na `lib.rs`. Esse n√≥ ser√° derivado de `CanvasLayer`, que √© usado para desenhar objetos independentes na tela um n√≠vel acima do resto do jogo. Feito isso, crie uma nova cena utilizando esse n√≥ como raiz, salve-a como `hud.tscn`, adicione os seguintes n√≥s como filhos:

- um `Label` chamado `ScoreLabel`
- um `Label` chamado `Message`
- um `Button` chamado `StartButton`
- um `Timer` chamado `MessageTimer`

Vamos ajustar a fonte e o tamanho do texto nos _labels_ e no bot√£o, em cada um dos tr√™s procure por `Control` > `Theme Overrides` no inspetor, em `Fonts` clique em `Load` e adicione a fonte guardada na pasta `fonts`, depois altere `Font Sizes` para `64px`. 

Todos esses componentes herdam de `Control` o que permite eles serem arranjados em **√¢ncoras**, basicamente √© um jeito de ajustar em posi√ß√µes fixas da tela. Ao selecionar qualquer um desses um novo conjunto de bot√µes aparecer√° na barra superior, fa√ßa uso dos _presets_ e ajuste de acordo.

<img width="293" height="331" alt="image" src="https://github.com/user-attachments/assets/aae2c09c-6f2d-4961-accb-01e438552c05" />

1. **ScoreLabel**: Adicione `0` ao campo de texto no inspetor, configure _Horizontal Alignment_ e _Vertical Alignment_ para `Center`, escolha o preset de √¢ncora `Center Top`;
2. **Message**: Escreva `Dodge the Creeps!` na caixa de texto, configure o alinhamento do texto para `Center`, sete o atributo "Autowrap Mode" para `Word`, assim o texto quebrar√° de linha. Em `Control` > `Layout/Transform` sete `Size X` para `480`. Escolha o preset de √¢ncora como `Center`; e
3. **StartButton**: Adicione o texto `Start`, em `Control`>`Layout/Transform` sete `Position Y` para `580`.

Por √∫ltimo, em `Message` configure `Wait Time` para `2` e `One Shot` para `On`. N√£o esque√ßa de instanciar sua cena HUD com a cena principal, assim como fizemos com Player.

<img width="390" height="562" alt="image" src="https://github.com/user-attachments/assets/0a53d79b-3c83-48d0-9854-6bbae29c5543" />

### Scripts da HUD

Vamos implementar as funcionalidades da nossa HUD, primeiro queremos que o jogo comece quando o bot√£o for apertado, j√° vamos nos adiantar e criar um sinal para isso.
```rust
/// hud.rs
// ...
#[signal]
pub fn start_game();
```

Vamos criar fun√ß√µes para atualizar a pontua√ß√£o, editar o conte√∫do da mensagem e mostrar a tela de _game over_. Implementamos tamb√©m as fun√ß√µes para acessar os n√≥s filhos de forma mais r√°pida.

```rust
/// hud.rs
// ...
pub fn set_score(&mut self, score: u32) {
    self.score_label().set_text(score.to_string().as_str());
}

pub fn show_text(&mut self, text: &str) {
    let mut msg_label = self.message_label();
    msg_label.set_text(text);
    msg_label.show();

    self.message_timer().start();
}

fn message_label(&self) -> Gd<Label> {
    self.base().get_node_as("Message")
}

fn score_label(&self) -> Gd<Label> {
    self.base().get_node_as("ScoreLabel")
}

fn start_button(&self) -> Gd<Button> {
    self.base().get_node_as("StartButton")
}

fn message_timer(&self) -> Gd<Timer> {
    self.base().get_node_as("MessageTimer")
}
```

Nada muito interessante nessas fun√ß√µes para ser dito, exceto que queremos que a mensagem tenha um tempo temporizador isso vai ser √∫til para saber quando trocar mensagem, como no fim de jogo por exemplo.

J√° para nossa fun√ß√£o de gameover, queremos mostrar uma mensagem de "GameOver" e depois mostrar um bot√£o convidando o usu√°rio a reiniciar o jogo. Para isso, precisamos criar um temporizador de uso √∫nico com dois segundos de vida (tempo o bastante para mostrar a primeira mensagem), conectamos esse temporizador com uma fun√ß√£o auxiliar `show_start_button`.
```rust
pub fn show_gameover(&mut self) {

    self.show_text("Game Over!");

    // criamos um timer de uso unico e esperamos ele acabar
    let timer = self.base().get_tree().unwrap().create_timer(2.0).unwrap();
    timer.signals()
        .timeout()
        .connect_other(self, Self::show_start_button);
}

fn show_start_button(&mut self) {
    let mut msg = self.message_label();
    msg.set_text("Dodge the Creeps!");
    msg.show();
    
    self.start_button().show();
}
```

> `create_timer` √© uma √≥tima fun√ß√£o caso voc√™ queira adicionar delays ou pausas sem introduzir n√≥s extras na sua cena.

N√£o podemos nos esquecer das funcionalidades, queremos que quando o bot√£o seja apertado o sinal de `start_game` seja emitido. Tamb√©m queremos que a mensagem seja escondida depois que o temporizador encerrar.

```rust
// dentro de impl ICanvasLayer
fn ready(&mut self) {
    self.start_button()
        .signals()
        .pressed()
        .connect_other(self, Self::on_start_button_pressed);

    self.message_timer()
        .signals()
        .timeout()
        .connect_other(self, Self::on_message_timer_timeout);
}

// dentro de impl HUD
#[func]
fn on_start_button_pressed(&mut self) {
    self.start_button().hide();
    self.signals().start_game().emit();
}

#[func]
fn on_message_timer_timeout(&mut self) {
    self.message_label().hide();
}
```

Agora precisamos conectar nossa HUD com a cena principal, v√° para `main_game.rs`, adicione `Hud` a nossa estrutura da mesma forma que Player. N√£o esque√ßa de adicionar `hud: OnReady::from_node("HUD")` no construtor. 

```rust
#[derive(GodotClass)]
#[class(base=Node)]
pub struct Main {
    mob_scene: OnReady<Gd<PackedScene>>,
    player: OnReady<Gd<Player>>,
    hud: OnReady<Gd<HUD>>,

    score: u32,
    base: Base<Node>
}
```

Vamos iniciar o jogo quando o sinal `start_game` for emitido, adicione essas linhas no final da fun√ß√£o `ready`.
```rust
self.hud
    .signals()
    .start_game()
    .connect_other(&game, Self::new_game);
```

Em `game_over` adicione a seguinte linha para mostrar a mensagem de fim de jogo.
```rust
self.hud.bind_mut().show_gameover();
```
Por fim, edite `new_game` e `on_score_timer_timeout` para atualizar a pontua√ß√£o do jogo.
```rust
// new_game
//...
self.hud.bind_mut().set_score(self.score);
self.hud.bind_mut().show_text("Get Ready");
```
```rust
// on_score_timer_timeout
self.hud.bind_mut().set_score(self.score);
```

Rode o jogo e voc√™ ver√° que ele est√° funcionando!

### Removendo inimigos

Ao reiniciar o jogo voc√™ ver√° que os inimigos permanencem na tela entre jogadas, precisamos delet√°-los sempre que o jogo reiniciar, podemos fazer isso de um jeito bem f√°cil com **grupos**, ou seja podemos categorizar nossos inimigos sendo do mesmo grupo e aplicar uma fun√ß√£o sobre eles. V√° para a `mob.tcsn`, selecione o n√≥ raiz e v√° para a aba `Node` (a mesma do inspetor) e clique em "Groups", adicione um novo grupo chamado `mobs`.

<img width="290" height="238" alt="image" src="https://github.com/user-attachments/assets/26616346-49a0-4f77-960b-60b3581e468d" />

Agora todos os inimigos pertencem ao grupo mobs. De volta ao Rust, na fun√ß√£o `new_game` adicione a seguinte linha. Ela vai chamar a fun√ß√£o `queue_free` para todos os elementos no grupo "mobs".
```rust
self.base().get_tree().unwrap().call_group("mobs", "queue_free", &[]);
```


## Toques finais

Com nosso jogo funcionando podemos adicionar alguns toques cosm√©ticos, como cores e m√∫sica, vamos encerrar esse jogo com chave de ouro.

Hora de tirar esse fundo cinza gen√©rico e dar um toque de eleg√¢ncia, crie um n√≥ do tipo `ColorRect` e fa√ßa ele ser o primeiro n√≥ abaixo da `Main`, assim ele estar√° no fundo da tela. Ajuste a √∫nica propriedade, `Color`, para a cor que voc√™ quiser e em `Layout` > `Anchors Preset` ajuste para `Full Rect`. Agora temos um plano de fundo , com uma cor mais interessante. Voc√™ pode botar uma imagem usando o n√≥ `TextureRect`, leia mais [aqui](https://docs.godotengine.org/en/stable/classes/class_texturerect.html#class-texturerect).

### Efeitos sonoros

Poucas coisas s√£o mais legais que m√∫sicas de videogame, felizmente nossos assets cont√©m duas _soundtracks_ para tocarmos, uma vai rodar durante o jogo todo, outra √© um som para quando o jogador morrer. Adicione dois n√≥s do tipo `AudioStreamPlayer` √† `Main`. Chame uma de `Music` outra `DeathSound`. Para cada uma, acesse a propriedade de `Stream`, clique em `Load`, escolha o √°udio correspondente da pasta `art`. Para fazer o √°udio tocar em _loop_, clique na seta de Stream, selecione `Make Unique`, e clique no arquivo de Stream, ent√£o selecione a op√ß√£o `Loop`.

<img width="387" height="335" alt="image" src="https://github.com/user-attachments/assets/cc442388-a5c9-4572-8330-898e263b446c" />

Para o c√≥digo, crie uma fun√ß√£o `music` e `deathsound` para acessar os n√≥s, inicie a m√∫sica com `self.music().play()` em `new_game`, pare-a em `game_over` e toque deathsound.

```rust
fn new_game() {
    ...
    self.music().play();
}

fn game_over() {
    ...
    self.music().stop();
    self.deathsound().play();
}
``` 

### Shortcuts

Seria bem conveniente poder apertar uma tecla para come√ßar o jogo n√£o √©? ~~N√£o!? fds faz parte da aula.~~ Isso √© poss√≠vel por meio de um atalho ligado ao n√≥ `Button`, veja como fazer isso.

Em `Project` > `Project Settings` > `Input Map`, crie uma a√ß√£o chamada `start`, atrele uma tecla a ela, no meu caso ser√° `Space` a tecla de espa√ßo. Na `HUD`, selecione `StartButton` e v√° para a inspe√ß√£o, dentro da propriedade **Shortcut**, acesse **Events**, clique para adicionar um novo elemento, clique em **Array[InputEvent](size 0)** e selecione **InputEventAction**, nomeie como `start`. 

> Se voc√™ tiver um controle de v√≠deo game tamb√©m pode adicionar como shortcut!

<img width="410" height="461" alt="image" src="https://github.com/user-attachments/assets/68101180-2c23-436f-97cd-2ba26dc1119f" />

√â s√≥ isso, est√° feito, voc√™ completou seu jogo, meus parab√©nsü•á!

### Exportando o Jogo

N√£o adianta nada criar o jogo mais incr√≠vel de todos se voc√™ n√£o puder compartilh√°-lo. Vamos exportar nosso jogo para um execut√°vel. Antes de tudo, compile a biblioteca do Rust para a vers√£o de _release_, ou seja, alguns elementos de debug ser√£o retirados e otimiza√ß√µes ser√£o feitas.
```sh
cargo build --release
```

Abra a op√ß√£o _Editor_ > _Manage Export Templates_, e baixe a vers√£o mais recente para exportar seu projeto. A instala√ß√£o pode demorar um pouco mas √© com ele que o Godot vai criar o seu execut√°vel.

<img width="740" height="402" alt="image" src="https://github.com/user-attachments/assets/1f6acf78-2cab-4da9-b493-cbccf8aba100" />

Agora v√° para _Project_ > _Export..._, clique em _Add_ e escolha o seus sistema operacional e clique em `Export Project`, clique em Ok, escolha um nome e confirme.

<img width="920" height="605" alt="image" src="https://github.com/user-attachments/assets/4569ce57-8328-43df-b8bb-16a154c76086" />

Protinho! Alguns arquivos e um execut√°vel ser√£o criados para voc√™ dentro da pasta do seu projeto. Pegue o execut√°vel, o arquivo `.so` (a biblioteca criada por n√≥s, copiada para a pasta godot) e um arquivo `.pck`, compacte-os em um ZIP e compartilhe com seus amigos, fam√≠lia ou interesse amoroso.

## Continuando sua jornada

Nossa! Voc√™ chegou longe, essa foi uma longa jornada. Espero muito que voc√™ tenha aprendido algo sobre desenvolvimento de jogos e Rust e que tenha gostado desse tutorial. Caso tenha tido d√∫vidas, queira nos dar sugest√µes ou bater papo abra uma issue ou mande uma mensagem, ficaremos felizes com isso.

Voc√™ pode estar se perguntando "o que eu fa√ßo com a minha vida agora?", essa √© uma resposta que eu n√£o tenho. Mas se quiser continuar aprendendo aqui vai algumas sugest√µes:

- Brinque com o que voc√™ j√° fez, mude as cores de fundo, adicione powerups ou salve o estado do jogo em um arquivo;
- Fa√ßa projetos parecidos, o [Tutorial Oficial tem um jogo 3D](https://docs.godotengine.org/en/stable/getting_started/first_3d_game/index.html), experimente faz√™-lo!
- Leia o manual do Godot para saber mais sobre os n√≥s dispon√≠veis e o que eles fazem, mal tocamos a superf√≠cie nesse curso;
- Aprenda mais sobre desenvolvimento de jogos com Godot, como boas pr√°ticas e padr√µes de projeto;
- Veja como utilizar mais as funcionalidades do Rust, como enums, multi-threading, etc;
- Compartilhe o que voc√™ est√° fazendo e procure pessoas que possam de ajudar e incentivar; e
- Divirta-se e relaxe! N√£o tente fazer o pr√≥ximo GTA6, comece por jogos simples, tente criar sistemas isolados e reutiliz√°veis tipo invent√°rio ou anima√ß√£o de personagens.

Por hoje √© s√≥ isso, espero que tenha gostado dessa jornada, tor√ßo para que continue nessa estrada. At√© a pr√≥xima!
