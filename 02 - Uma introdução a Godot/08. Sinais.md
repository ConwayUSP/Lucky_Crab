# 08. Sinais

Olá novamente! Vamos falar agora de uma estrutura muito útil disponível no Godot. **Sinais** ou _Signals_ são uma ferramenta que implementa o padrão [_Observador_](https://refactoring.guru/pt-br/design-patterns/observer), ou seja, objetos estão inscritos para serem notificados caso um sinal seja emitido. Exemplos de sinais: temporizadores, informe de dano, ação do teclado, mensagem recebida, etc.

## Criando sinais

Para criar um sinal dentro do Rust declaramos a assinatura de uma função marcada com o macro `#[signal]` dentro de um bloco `#[godot_api]`.

```rust
#[derive(GodotClass)
#[class(init, base=Node2D)]
struct Player {
    hp: u32,
    base: Base<Node2D>
}

#[godot_api]
impl INode2D for Player {
    #[signal]
    fn tomou_dano(dano: u32);
}
```

Declaramos apenas a assinatura (nome, argumentos e retorno), o corpo da função fica por responsabilidade da API do Godot. Agora queremos que essa função seja chamada sempre que nosso jogador tomar dano.

## Conectando sinais

A API oferece um meio bem legal para acessar os sinais registrados. Nossos nós podem chamar o método `signals()` que permite acessar todos os sinais registrados. Para se inscrever em um sinal, existem três formas, tudo depende de onde sua função se encontra.

### Mesmo instância/objeto

Ou seja estamos na mesma instância ou estrutura. Nesse caso utilizamos a função `connect_self` passando a função que será executada quando nosso sinal for emitido. Vejamos o exemplo do jogador, sempre que tomarmos dano, temos que atualizar nossos pontos de vida.

```rust

impl Player {
    fn on_tomou_dano(&mut self, dano: u32) {
        self.hp -= dano;
    }
} 

#[godot_api]
impl INode2D for Player {
    #[signal]
    fn tomou_dano(dano: u32);

    fn ready(&mut self) {
        self.signals()
            .tomou_dano()
            .connect_self(Self::on_tomou_dano);
    }
}
```

Declaramos nossa função `on_tomou_dano` (é comum utilizar o prefixo `on` nesses casos), que atualiza a vida do jogador. Já na função `ready`, conectamos o nosso sinal com essa função. Assim dizemos que `on_tomou_dano` está inscrita para receber sinais de `tomou_dano`. Simples assim criamos nosso primeiro sinal.

###  Objetos diferentes

Caso nossa função operadora esteja em outro objeto ou instância que seja diferente de `self`, precisamos usar a função `connect_other`. Isso pode ser útil quando uma ação que nosso entidade sofreu afeta entidades terceiras. Por exemplo, se temos um escudo equipado, queremos que o escudo tomem dano e não nós! Veja uma atualização do exemplo:

```rust

fn ready(&mut self) {
    self.signals()
        .tomou_dano()
        .connect_other(&self.shield, Shied::on_tomou_dano);
}
```

### Funções estáticas/sem objetos

Em último caso, digamos que nossa função não esteja atrelada a nenhum objeto ou seja uma função estática da nossa estrutura (sem o atributo `self`). Nessa situação usamos o método `connect`.

```rust
fn ready(&mut self) {
    self.signals()
        .tomou_dano()
        .connect(|amount: u32| {
            // escreve amount na saida padrao
            println!("Amout: {amout}");
        });
}
```

Isso pode ser útil para atualizar variáveis globais, através de _singletons_ ou outros efeitos que não necessariamente envolvam a aplicação como um todo.

## Emitindo sinais

Vimos como interceptar e reagir a sinais, agora precisamos saber como **emitir** esses sinais na nossa aplicação. Fazer isso é na verdade bem fácil, precisamos chamar um método chamado `emit()`. Para o exemplo do nosso jogador, digamos que uma criatura tenha nos atingido e queremos emitir um sinal de dano.

```rust
// impl Player {
// ...

fn foi_acertado(&mut self) {
    let amount = 10;
    self.signals().tomou_dano().emit(amout);
}
```

Assim sempre que formos acertados (imagine um cálculo para fazer isso), emitimos um sinal de dano e nosso sistema agirá de acordo, atualizando a saúde do jogador, alterando um dado na tela ou emitindo um som. 

Essa foi nossa curta introdução
