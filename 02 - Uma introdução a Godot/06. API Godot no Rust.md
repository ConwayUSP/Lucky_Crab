# Interagindo com o Godot através do Rust

Bem-vindo de volta, jovem *padawan*, na sua última lição você viu como configurar o Godot para rodar com Rust. Agora está na hora de aprender a como utilizar elementos do Godot no Rust. Para fazer isso, vamos mostrar alguns elementos da **API do Godot** e outras particularidades. Essa API é como um kit de ferramentas que vai trazer funcionalidades nativas do Godot para nosso código em Rust, fazendo adaptações às características intrínsecas do Rust.

> Mas pera aí, o que diabos é uma *API*? A resposta é simples, uma *API* é uma *Application Programming Interface*, prontinho, vamos continuar... Brincadeira, uma API é um tipo de software feito para programas se comunicarem entre si.

> É um termo meio genérico para definir essa ponte, onde funcionalidades são expostas de modo mais simplificado e programas (e programadores) podem utilizá-las. O que você precisa saber é que essa API do Godot permite que programas em Rust acessem funcionalidades do Godot Engine. Caso tenha ficado com dúvida ou queira saber mais [clique aqui](https://pt.wikipedia.org/wiki/Interface_de_programa%C3%A7%C3%A3o_de_aplica%C3%A7%C3%B5es).

## Tipos padrão (*builtins*)

Assim como o Rust, o Godot (o GDScript mais especificamente) também tem um conjunto de tipos padrão da linguagem. Vamos apresentar aqui suas versões no Rust e como instanciá-los.

### Tipos Primitivos

Os tipos `int`, `float`, `real` e `bool`, possuem equivalentes diretos com os tipos primitivos do Rust  (`i64`, `u8`, `f32`, `f64`, `bool`, etc.) e são criados da mesma maneira, então por aqui nada mudou muito.
### Tipos de String

Chegamos na primeira diferença, Godot possui **três tipos** de string que emergem no Rust como:

- `GString`: uma string de propósito geral;
- `StringName`: uma string otimizada para ser identificadores de classes e ações; e
- `NodePath`: representa um caminho para um *Node*.
Quando trabalhando com referências você pode passar strings do Rust como se fossem strings do Godot, ou usar os métodos `from` e `into` para convertê-las. Veja os exemplos:

```rust
label.set_text("ello"); // &str
let string = String::from("ello");
label.set_text(&string); // &String

label.set_text(&GString::from("ello")); // &GString
label.set_text(&"ello".into()); //&GString

// Para converter um StringName para GString chamamos o método `arg`
let string_name = StringName::from("ello");
label.set_text(string_name.arg()) // StringName -> GString
```

### Arrays e Dicionários

Em adição, o Godot vem com algumas coleções extras, a primeira é `Array<T>`, um array capaz de armazenar tipos do Godot. Além disso, temos o `VariantArray` que na verdade é um *alias* para `Array<Variant>`. O tipo `Variant` permite encapsular qualquer outro tipo, portanto, você pode criar arrays que armazenam mais de um tipo. 

Já o tipo `Dictionary` mapeia chaves e valores, onde ambos são do tipo `Variant`. Todos essas coleções oferecem macros para sua construção:

```rust
let arr: Array<i64> = array![1, 2, 3];
let varr: VariantArray = varray![1, "apples", false];
let dic: Dictionary = dict!{"fish": "net", 1: 0};
```

Esses tipos são semelhantes aos tipos `Vec<T>` e `HashMap<K, V>` do Rust, porém eles implementam *contadores de referências* (lembra do capítulo sobre ponteiros `Rc`?), ou seja, quando você tenta cloná-los, eles apenas retornam um ponteiro para a mesma instância. Para acessar elementos e iterar sobre eles usamos dois métodos `at` e `iter_shared`. Veja os exemplos:

```rust

let a = array![1, 2, 6, 3, 7, 0];
let b = dict!{1: 'a', 2: 'b', 3: 'c'};

println!("{}", a.at(1)); // 2
println!("{}", b.get(1).unwrap()); // 'a'

for el in a.iter_shared() {
	println!("element: {el}");
}

for (key, value) in b.iter_shared() {
	println!("{key}: {value}");
}
```

Por fim, temos a última coleção: o `Packed*Array`, que serve para guardar elementos de modo mais eficiente (compactados). O `*` é um *placeholder* para outros tipos, por exemplo `PackedByteArray`, `PackedInt32Array`, `PackedVector2Array`. Diferente do `Array`, esses arrays compactos implementam um mecanismo chamado *copy-on-write* (cópia em escrita), ou seja, escrever no array produz uma cópia e cloná-lo também criará uma cópia nova de seus conteúdos. Felizmente, fazer essa cópia tem um custo computacional relativamente barato, garantindo mais eficiência ao seu programa. Veja como utilizar essa estrutura:

```rust
let a = PackedByteArray::from(&[9, 1, 23]);
println!("{}", a[0]); // 9
a[0] = 127;

// Podemos transformar esse array em um slice
let b = a.subarray(0, 2);
b.as_slice(); // &[u8]
```

### Tipos Geométricos

Esses tipos representam certas características geométricas, o que é muito útil para um jogo.
#### Vetores

Temos vetores de 2, 3 e 4 dimensões, estes podem ser de pontos flutuantes ou de inteiros, são eles: `Vector2`, `Vector2i`, `Vector3`, `Vector3i`, `Vector4` e `Vector4i` (os marcados com `i` são de inteiros). Todos eles contém componentes (de `x`, `y`, `z` a `w`), mas também podem ser acessado como um array. Veja só:

```rust
let position = Vector2::ZERO; // um vetor zerado
position.x += 1.0_f32;
println!("{position}"); // (1.0, 0.0)
println!("{}", position[1]); // 0.0
```
Diversos métodos são implementados para operar com esses vetores, [confira-os aqui](https://godot-rust.github.io/docs/gdext/master/godot/builtin/struct.Vector2.html).

#### Caixas de colisão

Estruturas ou formatos geométricos úteis para simular caixas de colisão. Temos, `Rect2`, `Rect2i` e `Aabb`. Os dois primeiros são retângulos, com um vetor `position` e outro para `size`, o último é uma caixa tri-dimensional. Você, normalmente, usaria os dois primeiros para um jogo 2D e o último para um 3D.

```rust
// Criamos formas na posição zero com diferentes tamanhos.
let rect = Rect2::new(Vector2::ZERO, Vector2::new(1.0, 2.0));

let aabb = Aabb::new(Vector3::ZERO, Vector3::new(0.5, 3.0, 1.0));
```

#### Matrizes

Matrizes são muito úteis para cálculos de renderização, movimentação e mais. Temos os seguintes tipos, `Transform2D` (2x3), `Transform3D` (3x4) e `Basis` (3x3), `Projection` (4x4).

```rust
let ident = Transform2D::IDENTITY; // matrix identidade
let mat = Basis::from_rows(Vector3::ZERO, Vector3::ONE, Vector3::splat(3)); // Uma matrix 3x3 com uma fileira de zeros, uma de 'uns' e outra de 'tres'
```

~~_"Aiii mais e se eu quiser uma matriz 420x69"_.~~
Se você checar a documentação verá que essas matrizes são só arrays do Rust com vetores dentro, então você pode criar suas próprias matrizes também!

#### Outros

Por último, temos uma estrutura chamada `Quaternion`, usada para rotações, e o `Plane`, para planos geométricos. a, então *busquem ~~comer cimento~~ conhecimento*! Confira a matemática dos [Quartenions](https://pt.wikipedia.org/wiki/Quaterni%C3%A3o), e a documentação do [Plane](https://godot-rust.github.io/docs/gdext/master/godot/builtin/struct.Plane.html). Eles podem ser úteis em alguns casos específicos, você vai saber quando usá-los! ~~Ou não...~~

### Miscelâneas

Assim como você, alguns tipos não se encaixam em padrões e conformidades ~~-isso é mentira~~. Por isso, joguei todos eles aqui nessa última seção.

- `Color`: um `Vector4`, possui 4 componentes para representar cores em RGBA (`rgba`);
- `ColorHsv`: representa cores em HSVA, também possui 4 componentes (`hsva`);
- `RID`:  de *resource ID*, é um identificador para *resources*.
-  `Callable`: representa uma função dentro do Godot.
- `Signal`: parte da API de sinais do Godot, veremos isso depois, ele também possui um par chamado `TypedSignal`. Você provavelmente vai querer usar o último.
## Objetos (*Objects*)

Ufa, ainda bem que acabou...né?

~~Hahah~~ Não! Ainda temos muito a ver! Está na hora de dar uma olhada em *objects*. Contudo, vamos antes esclarecer as coisas...O que é um *object* **nesse contexto**? Bom, um *object* é uma instância de uma *classe* do Godot, representado pelo tipo `Object`, ele é a classe-mãe dos tipos `Node`, `Resource` e `RefCounted` por exemplo. Nós também podemos criar nossas classes com o macro `#[derive(GodotClass)]`. Em suma, pense em uma classe como uma estrutura visível ao Godot e um *object* é uma instância dela.

> Mais uma nota de esclarecimento. Os tipos *built-ins* **não** são classes! Mesmo que às vezes chamem eles de classes (eu culpo a orientação a objetos por isso).

### Herança e criação de classes

Herança é um conceito fundamental dentro do Godot, você viu isso no exercício de *Nós e Cenas*, onde criamos classes derivadas e estendemos suas funcionalidades. Entretanto, Rust não tem herança como as outras linguagens, contornamos isso utilizando **composição**. Antes de ver exemplos, vamos entender como as classes funcionam:

Toda classe que criarmos no Rust terá uma classe base do Godot, e esta:
1. Pode ser herdada de `Node`, e atrelada a nossa árvore de nós e a cenas. Mas, precisa ser adicionada a cena e desalocada manualmente; ou
2. Herdar de `RefCounted`, útil para mover dados sem interagir com a cena, a memória é gerenciada por contador de referências; ou
3. Herdar diretamente de `Object`, o que é incomum, pois você precisará gerenciar a memória manualmente e não terá muitos benefícios. *Use com cuidado!*

### Apresentando o ponteiro inteligente Gd

Apresentamos aqui o tipo `Gd<T>`, ele é um ponteiro inteligente responsável por diversas funcionalidades da nossa API, suas responsabilidades incluem:
- Armazenar referências para **todos** os objetos do Godot, incluindo as estruturas definidas por você;

- Gerenciar a memoria de tipos com contagem de referências;
- Garantir *mutabilidade interna* dos objetos (lembra do `RefCell`?);
- Detectar e prevenir vazamentos de memória e *Undefined Behavior*; e
- Fazer uma ponte entre o Rust e o Godot engine.

Um exemplo seria envolver um nó, `Gd<Node2D>`, ou um outro recurso,`Gd<RigidBody2D>`, para ser usado no nosso código. 

Entendido, mas como eu posso construir uma classe? Existem dois modos, dependendo do tipo de gerenciamento de memória usado:

1. Para contadores de referência usamos `new_gd`, como em `TcpServer::new_gd()`;
2. Para gerenciamento manual usamos `new_alloc`, como em `Node2D::new_alloc()`;

Essas funções são extensões de *traits*, `NewGd` e `NewAlloc`, respectivamente.

Ótimo, e o que eu posso fazer agora? Uma vez com seu objeto, você pode interagir com ele de algumas formas:

- obter o ID do objeto com `instance_id()`;
- conseguir uma nova referência com  `clone()`;
- destruir o objeto com `free()`;
- Fazer comparações com outros objetos.

Você também pode converter seu objeto para outras classes herdadas ou herdeiras, *up casting* e *down casting*, respectivamente. Veja um exemplo de *down casting*:

```rust
// down castings podem falhar
let node: Gd<Node> = ...;
// Vai dar certo com certeza
let node2d = node.cast::<Node2D>(); // ou
let node2d: Gd<Node2D> = node.cast(); 

// Talvez dê errado
let sprite: Result<Gd<Sprite2D>, Box<dyn std::error::Error>> = node.try_cast();
```

Exemplos de *up casting*: 

```rust
// Up castings sempre dão certo!
let node2d: Gd<Node2D>;
let node = node2d.upcast::<Node>();

// Também podemos criar referências
let noderef: &Node  = node2d.upcast_ref();
```

Por último, para liberar a memória dos nossos objetos quando criados com um `new_alloc()`, temos que chamar `Gd::free()` ou mover os objetos a um método que faça isso por nós, como `queue_free()`. Ao usarmos `new_gd()` nem temos que nos preocupar com isso. Felizmente, o compilador do Rust é poderoso o bastante para nos avisar se qualquer vazamento possa acontecer e nos ajudará a tratá-lo.

Em próximos capítulos veremos como usar nossos objetos.

## Funções

Múltiplas funções e métodos estão disponíveis através dessa API, vamos explorar alguns dos recursos disponíveis.

Os métodos estão juntos com suas respectivas estruturas nos módulos `godot::classes` e `godot::builtins`. Além do mais, a maioria dos utilitários estão disponíveis em `godot::prelude` para serem acessados mais rápido.

Você pode chamar funções e métodos como em qualquer outra estrutura do Rust:

```rust
let node = Node::new_alloc();
let path = node.get_path();

let child = Node::new_alloc();
node.add_child(child);
```

### Singletons

*Singletons* são classes que permitem acessar informações globais do Godot, como por exemplo eventos e entradas do usuário:

```rust
let input = Input::singleton() // ganhamos uma instância de Input
if input.is_key_pressed("up") {
	position.y += 10;
}
```

### Parâmetros padrão

No GDScript, parâmetros de funções podem ter um valor padrão que é utilizado quando um valor não é passado, isto não existe no Rust [1], então a API fornece uma interface diferente.

1. Imagine essa função do Godot:

```gdscript
Button add_button(String text, bool right=false, String action="")
```

2. No rust teremos uma função com apenas o valor obrigatório:

```rust
let button = Button.add_button("Yes");
```

3. Porém, também teremos um construtor para nossa função com o sufixo **`_ex`**: 

```rust
// Usamos outros métodos para adicionar os parâmetros opcionais terminamos a construção do nosso objeto com o método `done()`
let button = Button.add_button_ex("Yes")
	.right(true)
	.done();
let button2 = Button.add_button_ex("No")
	.action("confirm")
	.done();
``` 

[1]: É possível utilizar uma estrutura que implementa o trait Default, mas esse não é o ponto.

### Chamadas dinâmicas

Digamos que você tenha criado uma função dentro do GDScript e queira chamar ela no seu código em Rust, como fazer isso? A resposta é uma *chamada dinâmica*. Dois métodos estão disponíveis: `call()` e `try_call()` para casos de falha. Veja exemplos:

```rust
let node = get_node_as::<Node2D>("./meuScript");
// Criamos argumentos a partir de um slice de variants
let args = &["aaaa".to_variant(), 69.to_variant()];
let res: Variant = node.call("incredible_method", args);
// ou
let res2: Result<Variant, CallError> = node.try_call("failure_method", args);

```

Isto é tudo que precisamos saber por enquanto sobre como utilizar a API; mais à frente aprenderemos a criar jogos com Godot utilizando essas classes e métodos.

## Conclusão

Essa foi uma bela jornada. Agora você aprendeu sobre o básico da API do Godot, caso queira ir mais a fundo, a [documentação te espera](https://godot-rust.github.io/docs/gdext/master/godot/index.html). No próximo capítulo, vamos explorar como criar nossos próprios símbolos (classes, funções, etc). Até a próxima!

## Referências

As seguintes fontes foram usadas de referência:
 - [Using the Godot API de The godot-rust book](https://godot-rust.github.io/book/godot-api/index.html)
 - [godot crate API docs](https://godot-rust.github.io/docs/gdext/master/godot/index.html)