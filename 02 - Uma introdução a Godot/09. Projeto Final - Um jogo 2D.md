# Projeto Final

Muito bem caro aluno! Se você chegou até aqui foi graças ao seu esforço e perseverança. Você teve uma introdução à linguagem Rust e ao Game Engine Godot e como utilizá-los juntos. Agora chegou a hora de construirmos um jogo juntos para colocar em prática tudo que aprendemos.

## Especificações

O jogo que iremos construir se chama *"Dodge the Creeps"* ("Desvie das Criaturas"), será uma adaptação do jogo tutorial feito pelo Tutorial Oficial do Godot, a diferença é que usaremos Rust ao invés de GDScript. Isso é ótimo pois teremos um ponto de referência para o nosso projeto, o qual podemos voltar para comparar e tirar dúvidas. Se quiser ver o tutorial original [clique aqui](https://docs.godotengine.org/pt-br/4.x/getting_started/first_2d_game/).

> Nota: utilizaremos os mesmos assets (imagens e etc) que o tutorial original. Produzido por eles. Todos os direitos são reservados ao Godot Engine.

Ademais, o código fonte do projeto pode ser encontrado no nosso [github](https://github.com/ConwayUSP/DodgetheCreeps/tree/main).

## Criando nosso projeto

Antes de mais nada baixe os assets para o jogo nesse link
[dodge_the_creeps_2d_assets.zip](https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/dodge_the_creeps_2d_assets.zip). Vamos criar um novo projeto, seguiremos as mesmas etapas do capítulo 5 de scripts. Em uma pasta chamada `dodge-the-creeps` (ou o que você quiser).

### Configuração do Rust
Crie uma nova biblioteca do Rust: `cargo new rust --lib`. Entre nessa pasta e adicione a biblioteca do godot com `cargo add godot`. Agora, configure o arquivo `Cargo.toml` para que ele fique da seguinte forma:
```toml
[package]
name = "dodge_the_creeps"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib"]

[dependencies]
godot = "0.2.4"
```
Feito isso, vamos adicionar o _boilerplate_ da biblioteca, substitua o código no arquivo `src/lib.rs` por este:
```rust
use godot::prelude::*;

struct GameExtension;

#[gdextension]
unsafe impl ExtensionLibrary for GameExtension {}
```
> Dei o nome de `GameExtension` para nossa extensão, mas você pode escolher o nome que preferir.

Isto feito, compile a biblioteca com `cargo build`. Se tudo deu certo, podemos ir para o _setup_ do Godot.

### Configuração do Godot

Abra o Godot e crie um novo projeto dentro da pasta raiz. Darei o nome do projeto de `Dodge the Creeps`, mas a pasta se chamará `godot`. Veja na imagem abaixo:

<img width="250" height="250" alt="tela de criação de projetos do godot" src="https://github.com/user-attachments/assets/138a5d13-9038-4b51-9eed-4e22cbede11f" />

Agora dentro da interface do Godot vamos configurar adicionar nossos _assets_,  mas antes precisamos configurar a _viewport_ (tamanho da tela) que nosso jogo terá. Em _Project_ > _Project Settings_>, encontre a aba _Display_ e clique na opção _Window_, modifique os atributos _Viewport width_ e _Viewport height_ para `480` e `720` respectivamente. Agora nas opções de _Stretch_, configure _Mode_ para `canvas_item` e _Aspect_ para `keep`. Desse modo, nossa tela vai se manter consistente para diferentes tamanhos de tela.

Voltando aos nossos assets, extraia os arquivos dentro da pasta `godot`, o resultado serão duas pastas, `fonts` e `art`. Usaremos esses recursos nas próximas etapas. O seus sistema de arquivos deve ficar da seguinte forma:

<img width="293" height="286" alt="sistema de arquivos do godot" src="https://github.com/user-attachments/assets/24dd0219-35aa-44e7-a366-6ea8dfa55d6c" />

Isso feito, crie um arquivo `DodgeTheCreeps.gdextension` e escreva as seguintes linhas.
```toml
[configuration]
entry_symbol = "gdext_rust_init"
compatibility_minimum = 4.1
reloadable = true

[libraries]
linux.debug.x86_64 =     "res://../rust/target/debug/libdodge_the_creeps.so"
linux.release.x86_64 =   "res://../rust/target/release/libdodge_the_creeps.so"
windows.debug.x86_64 =   "res://../rust/target/debug/dodge_the_creeps.dll"
windows.release.x86_64 = "res://../rust/target/release/dodge_the_creeps.dll"
macos.debug =            "res://../rust/target/debug/libdodge_the_creeps.dylib"
macos.release =          "res://../rust/target/release/libdodge_the_creeps.dylib"
macos.debug.arm64 =      "res://../rust/target/debug/libdodge_the_creeps.dylib"
macos.release.arm64 =    "res://../rust/target/release/libdodge_the_creeps.dylib"
```

Muito bem, com isso nosso projeto está configurado, vamos partir para as próximas etapas.

## Criando o jogador

Primeiro de tudo, vamos criar nosso jogador. Abra a interface do Godot, na árvore de nós, clique em `Other Node`, pesquise por `Area2D` e clique em criar. Ainda na árvore, renomeie o nó para `Player`. Antes de mais nada, precisamos agrupar os nós filhos de _Player_, na barra de tarefas busque pelo ícone **Agrupar**, ou aperte `Ctrl-G`.

<img width="687" height="83" alt="agroupar-nos-filhos" src="https://github.com/user-attachments/assets/1ecd9155-ec36-4054-95e0-8c8704d7fc7b" />

Feito isso, aperte `Ctrl-A` para criar um filho do nó raiz, selecione `AnimatedSprite2D`, esse nó vai cuidar das animações e sprite do jogador. Selecione esse nó na árvore e vá para a coluna de inspeção (_Inspector_), procure por `Animation` > `Sprite Frames`, clique para criar um novo _Sprite Frames_. Isto criará uma nova aba inferior chamada _SpriteFrames_, nela temos uma lista de animações, cada animação é um conjunto de _sprites_ (imagens), vamos criar duas animações. Renomeie a animação `default` para `walk` e crie uma nova animação chamada `up`. Para adicionar _sprites_ basta selecionar a animação e arrastar imagens para a tela maior. Vamos adicionar algumas imagens, procure na aba de _FileSystem_ a pasta `art`, arraste as seguintes imagens para suas respectivas animações:

- `playerGrey_walk1` e `playerGrey_walk2` para `walk`; e
- `playerGrey_up1` e `playerGrey_up2` para `up`.

<img width="1278" height="349" alt="Animacoes" src="https://github.com/user-attachments/assets/cf98cf1d-8f22-4bbe-bfb1-2403946d3833" />

Temos um pequeno detalhe, nossas imagens são meio grandes para a tela que definimos antes, então vamos reduzir as imagens em 50%. Ainda com o nó `AnimatedSprite2D` selecionado, volte para o _Inspector_, procure por `Transform` > `Scale`, ajuste ambas coordenadas para `0.5`.

<img width="284" height="484" alt="ajustar-escala-do-jogador" src="https://github.com/user-attachments/assets/605c8760-a1e4-49a9-9140-66ff0f1fafcd" />

Seguindo, vamos adicionar uma _hitbox_ para nosso jogador. Crie um nó do tipo `CollisionShape2D` e em `Shape` selecione `CapsuleShape2D`, uma elispse azul se formará no centro do nosso jogador. Dê um zoom na tela de visualização e ajuste essa elipse para cobrir a maior parte do jogador.

<img width="474" height="488" alt="resize-player" src="https://github.com/user-attachments/assets/c59c3fae-37a1-4957-99f7-37b22eb19612" />

O jogador está pronto, vamos salvar essa cena com `Ctrl-S` e dar o nome de `player.tscn`, nossa cena irá aparecer em _FileSystem_. Muito bem! Está na hora de programar algumas funcionalidades. De volta ao Rust!
 
### Programando o jogador

Abra o arquivo `lib.rs` no seu projeto, como bons programadores que achamos que somos, vamos criar uma biblioteca bem modularizada. Primeiro crie um novo módulo para armazenar nossas entidades, com `mod entity`, e depois, uma pasta de mesmo nome com um arquivo `mod.rs` dentro dele. Nesse arquivo vamos declarar nosso o módulo para nosso jogador. 

```rust
/// entity/mod.rs
mod player;

// vamos deixar os a itens de player visivel para o escopo acima
pub use player::*;
```
Feito isso, crie um arquivo `player.rs` dentro da pasta `entity`, lá estará o código para nosso nó. Comecemos criando um espelho do nó raiz da nossa cena, com alguns atributos a mais que veremos a frente.

```rust
/// entity/player.rs
use godot::prelude::*;
use godot::classes::{ Area2D, IArea2D};

#[derive(GodotClass)]
#[class(base=Area2D)]
pub struct Player {
    #[export]
    speed: f32, // queremos que esse atributo apareça na UI do Godot

    screen_size: Vector2,
    base: Base<Area2D>
}

#[godot_api]
impl IArea2D for Player {
    fn init(base: Base<Self::Base>) -> Self {
        Self {
            speed: 400.0,
            screen_size: Vector2::ZERO,
            base  
        }
    }
}
```

Nós apenas criamos um _boilerplate_ da nossa classe e adicionamos dois atributos, `speed` e `screen_size`. Compile o código para adicionarmos essa classe a nossa árvore de cenas. Na UI, dentro da cena do jogador, crie um novo nó, esse nó deve ser do tipo `Player` (criado pelo Rust, não o que renomeamos!) e adicione a árvore de nós. Queremos que esse nó `Player` que contém nosso código em Rust seja o nó raiz da cena. Com o botão direito clique nesse nó e escolha a opção `Make Scene Root`. O novo Player será a raiz e o antigo, seu filho. Agora mova `AnimatedSprite2D` e `CollisionShape2D` para fora do nó antigo, e **apague** esse nó. Acabamos de substituir o nó `Area2D` pelo nosso nó customizável do Rust. Fazer isso dessa forma pode ser útil para primeiro modelar nossas cenas e depois adicionar funcionalidades.

<img width="290" height="470" alt="Screenshot from 2025-09-03 13-08-16" src="https://github.com/user-attachments/assets/9ad5160a-3bef-4081-b2bd-eb899d433f5f" />
<img width="280" height="470" alt="Screenshot from 2025-09-03 13-08-29" src="https://github.com/user-attachments/assets/3853df9e-0091-490c-b304-395df8146ccc" />
<img width="280" height="470" alt="Screenshot from 2025-09-03 13-08-56" src="https://github.com/user-attachments/assets/fa03b75a-46ea-4b9d-952c-c48b7795c91f" />

> Não esqueça de ativar o agrupamento desse novo nó `Player`. Aperte `Ctrl-G` ou ative na barra de ações.

Ainda na UI, vamos habilitar as funções do teclado para mover nosso jogador. Em `Project` > `Project Settings`, busque pela aba `Input Map`, nessa aba vamos mapear as entradas do teclado para ações específicas. No campo `Add new action` escreva `move_right` e aperte em `Add +`. Isso adicionará a ação à lista, selecione o _+_ nesse item.
<img width="1212" height="405" alt="Screenshot from 2025-09-03 13-09-44" src="https://github.com/user-attachments/assets/58c220f0-e512-44f4-8fcd-dd5cd1c2168d" />

Isto abrirá um _popup_ para atrelar eventos a sua ação. Procure por `Right` (representa a seta direita) e pela tecla `D`, adicione ambas. Desse modo, ambas tecladas vão produzir a mesma ação, mover o jogador para a direita). Repita para as outras teclas.
 
<img width="1173" height="370" alt="Screenshot from 2025-09-03 13-41-04" src="https://github.com/user-attachments/assets/089e9471-973e-46b8-a8e5-e3c2a6782baa" />

De volta ao código, vamos criar duas funções para nossa classe, `ready` é chamada quando nosso nó entra em cena, nela vamos atribuir o tamanho da tela.

```rust
/// entity/player.rs
impl IArea2D for Player {
//...

fn ready(&mut self) {
        if let Some(viewport) = self.base().get_viewport() {
            self.screen_size = viewport.get_visible_rect().size;
        }    
}
//...
```
A função `ready` acessa a `viewport` (dimensões da tela) e produz um `Vector2` representando esse tamanho, atribuindo a `screen_size`. Feito isso, vamos criar um sistema de movimentação.

```rust
/// entity/player.rs
// adicione Input nos seus imports
use godot::classes::{..., Input};
//...
fn process(&mut self, delta: f64) {
    let input = Input::singleton();
    let mut velocity = Vector2::ZERO;

    if input.is_action_pressed("move_right") {
        velocity += Vector2::RIGHT; // (1,0)
    }
    if input.is_action_pressed("move_left") {
        velocity += Vector2::LEFT; // (-1, 0)
    }
    if input.is_action_pressed("move_up") {
        velocity += Vector2::UP; // (0, -1)
    }
    if input.is_action_pressed("move_down") {
        velocity += Vector2::DOWN; // (0, 1)
    }

    let mut sprite = self.base_mut().get_node_as::<AnimatedSprite2D>("AnimatedSprite2D");

    if velocity.length() > 0.0 {
        // normalizamos o vetor para que a velocidade diagonal seja igual a velocidade horizontal/vertical
        velocity = velocity.normalized() * self.speed;
        sprite.play();
    } else {
        sprite.stop();
    }
    
    let mut position = self.base().get_global_position();

    position += velocity * delta as f32;
    position = position.clamp(Vector2::ZERO, self.screen_size);

    self.base_mut().set_position(position);
}
```

Destrinchando esse código, a função `process` é chamada a cada frame do jogo, e recebe `delta`, a variação de tempo entre este e o frame anterior. Isso dito, criamos uma instância de `Input`, uma classe utilitária para ler todos os tipos de entrada, isso nos permitirá verificar se eventos e ações ocorreram ou não. Depois, criamos um vetor velocidade, ele vai armazenar a direção (e mais tarde a força) do movimento. Cada _if_ checa se uma ação (ou melhor uma tecla) está sendo pressionada, se sim ele adiciona uma direção ao vetor velocidade. Com isso, o jogador pode se mover na diagonal se apertarmos duas teclas ao mesmo tempo. Por conseguinte, conferimos se o jogador está se movendo, se sim multiplicamos pela velocidade e executamos a animação, senão, desativamos a animação. Por último, pegamos a posição atual do jogador, atualizamos com base na velocidade e o tempo ($v * t = s$, física!), mas limitando para os limites da tela. Se você compilar e rodar essa cena (aperte `F6`) poderá mover seu jogador através da tela.

> Essa parte envolve alguns conceitos de vetores que não cabe entrarmos nesse tutorial, se precisar confira o material do Godot sobre o assunto [Matemátia Vetorial - Godot Tutorial](https://docs.godotengine.org/pt-br/4.x/tutorials/math/vector_math.html).


Vamos agora utilizar ajustar nossas animações, modifique o código da seguinte forma:

```rust
/// entity/player.rs

// fn process(...)
// ...
if velocity.length() > 0.0 {
    velocity = velocity.normalized() * self.speed;

            
    let animated;
    if velocity.x != 0.0 {
         animated = "walk";
         sprite.set_flip_v(false);
         sprite.set_flip_h(velocity.x < 0.0)
    } else {
         animated = "up";

         sprite.set_flip_v(velocity.y > 0.0);
    }

    sprite.play_ex().name(animated).done();

} else {
    sprite.stop();
}
```

Incluimos uma pequena condicional: se estivermos nos movimentando no eixo x, usaremos a animação `walk` com os olhos virados para o sentido do movimento (invertendo a imagem no eixo horizontal), e se estivermos indo para baixo, invertemos a imagem no eixo vertical. 

Continuando, vamos preparar o sistema de colisão do jogador, espero que lembre da aula sobre **sinais**! Primeiro crie um novo bloco de implementação com nosso signal, ele se chamará `hit`.

```rust
#[godot_api]
impl Player {
    #[signal]
    fn hit();
}
```

Agora temos que atrelar esse sinal a um outro que irá ser emitido sempre que um corpo colidir com nosso jogador, ele será chamado de `on_player_body_entered`.

```rust
#[godot_api]
impl Player {
    #[signal]
    fn hit();

    #[func]
    fn on_player_body_entered(&mut self, _body: Gd<Node2>) {
        self.base_mut().hide();

        self.signals().hit().emit();

        let mut collision_shape = self
            .base()
            .get_node_as::<CollisionShape2D>("CollisionShape2D");
        collision_shape.set_deferred("disabled", &true.to_variant());
    }
}
```
Na definição de `on_player_body_entered` definimos que caso haja uma colisão devemos remover o jogador da tela, emitir um sinal de _hit_ e desabilitar a _hitbox_.

> Usamos `set_deferred` ao invés de `set_disabled` pois desativar a colisão durante processo de checagem pode causar erros, desse modo o sistema vai desabilitar a colisão quando for seguro.

Além disso, temos que registrar essa função com sua contra-parte do Godot. Adicione o seguinte trecho ao final da função `ready`:

```rust
// Conectamos a função body_entered do Godot com nossa função customizada.
 self.signals()
     .body_entered()
     .connect_self(Self::on_player_body_entered);
```

Antes de continuar temos que definir uma função que vai ser executada para resetar o estado do jogador quando o jogo começa/recomeça, chamaremos ela de `start`.

```rust
#[godot_api]
impl Player {
   // ...

   #[func]
   pub fn start(&mut self, pos: Vector2) {
       self.base_mut().set_global_position(pos);
       self.base_mut().show();

       let mut collision_shape = self
           .base()
           .get_node_as::<CollisionShape2D>("CollisionShape2D");

       collision_shape.set_disabled(false);
   }
```

Tudo que fazemos aqui é definir a posição inicial do jogador, habilitar sua hitbox e mostrar ele na tela. Deixaremos a função pública, pois ela será importante mais tarde.

Por enquanto terminamos de editar nosso jogador, para encerrar esse capítulo, é hora de fazer alguns inimigos!

## Criando os inimigos

Para criar nossos inimigos vamos repetir algumas das etapas da criação do jogador, então esteja pronto e se quiser volte um pouco e relembre. Primeiramente, crie um arquivo `mob.rs` dentro da pasta `entity`, não esqueça de declarar esse módulo e importá-lo no arquivo `mod.rs` (eu sei os nomes são muito parecidos, desculpe). Agora crie uma estrutura `Mob` derivada de `RigidBody2D` com o _boilerplate_ necessário.

```rust
use godot::prelude::*;
use godot::classes::{IRigidBody2D, RigidBody2D};

#[derive(GodotClass)]
#[class(base=RigidBody2D)]
pub struct Mob {
    base: Base<RigidBody2D>
}

#[godot_api]
impl IRigidBody2D for Mob {
    fn init(base: Base<Self::Base>) -> Self {
        Self {
            base
        }
    }
}
```

Volte para a UI e crie uma nova cena com `Ctrl-N` ou em `Scene` > `New Scene`. O nó raiz será nossa classe `Mob`, ela terá três filhos: `AnimatedSprite2D`, `CollisionShape2D` e `VisibleOnScreenNotifier2D`, os dois primeiros você já conhece, o último é para nos dizer se o inimigo está na tela ou não. **Não** esqueça de agrupar esses nós. Hora de configurá-los. Para o nosso `Mob`, configure `Gravity Scale` para `0.0`, ou seja, sem efeito de gravidade, ainda nesse nó, procure no inspetor por `CollisionObject2D` > `Mask`, desmarque o número `1` nessa propriedade. Desse modo, os inimigos não vão colidir uns com os outros.

<img width="283" height="338" alt="image" src="https://github.com/user-attachments/assets/51c8ff21-715a-4bc1-b06e-7e4963074c81" />

Para `AnimatedSprite2D` crie três novas animações: `walk`, `fly` e `swim`, arraste as respectivas imagens para cada uma delas. Cada animação será um inimigo diferente. Na propriedade `Animation Speed` de `Animation Frames` coloque `3.0`. Depois, reduza as imagens para `0.75` do tamanho original em `Scale` no inspetor. Por último, ajuste o tamanho da _hitbox_ para caber no inimigo, pode ser que você precise rodar a capsula, experimente a propriedade `Rotation`, também no inspetor.

<img width="513" height="371" alt="image" src="https://github.com/user-attachments/assets/9339fe59-eca1-461a-845f-d34fe0dbaf6f" />

Não esqueça de salvar a cena.
Agora, configurar nosso script. Crie a função `ready`, vamos selecionar uma animação para nosso mob de modo aleatório.

```rust
use rand::seq::{IndexedRandom};

fn ready(&mut self) {
    let mut sprite = self.base().get_node_as::<AnimatedSprite2D>("AnimatedSprite2D");

    let anime_names = sprite.get_sprite_frames().unwrap().get_animation_names().to_vec();
    let mut rgn = rand::rng();
    let animation = anime_names.choose(&mut rgn).unwrap();

    sprite.set_animation(animation.arg());

    sprite.play();
}
```
Simplesmente pegamos o nó de _sprite_ e os nomes de cada animação, criamos um vetor com esses nomes e selecionamos um nome aleatório para ser nossa animação.

> Adicione ao projeto a _crate_ `rand`, com `cargo add rand`, assim você terá utilitários e funções de aleatoriedade

Por fim, vamos criar uma função para desalocar esse mob caso ele saia da tela. Essa função se chamará `on_visibility_screen_exit`.

```rust
#[godot_api]
impl Mob {
    #[func]
    fn on_visibility_screen_exit(&mut self) {
        self.base_mut().queue_free();
    }
}
```

Com isso, completamos nosso inimigo e jogador! 

Ufa... foi uma jornada longa até aqui, vamos parar por enquanto por que estou escrevendo isso as três horas da manhã. Continuaremos para criar nossa cena principal, adicionar texto, pontuação e outras lógicas, finalizaremos no próximo capítulo, até logo!
